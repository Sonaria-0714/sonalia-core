<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SONALIA: CONCEPT INTEGRITY</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Consolas, sans-serif; }
        canvas { display: block; }

        /* --- 1. BOOT SEQUENCE --- */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 10000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 1s cubic-bezier(0.16, 1, 0.3, 1); cursor: pointer;
        }
        .logo-box { position: relative; text-align: center; }
        .logo-text {
            font-size: 5em; font-weight: 900; color: #fff; letter-spacing: 0.2em; margin: 0;
            text-shadow: 0 0 40px rgba(0,255,255,0.6);
            animation: glitch 4s infinite;
        }
        .logo-sub { 
            color: #00ffff; font-size: 0.9em; letter-spacing: 0.5em; margin-top: 15px; opacity: 0; 
            animation: fadeup 2s forwards 0.5s; font-family: monospace;
        }
        .loading-line { width: 0%; height: 2px; background: #00ffff; margin-top: 30px; animation: loadLine 3s cubic-bezier(0.2,1,0.2,1) forwards; }
        
        /* スタートボタン（クリック誘導） */
        .start-hint {
            margin-top: 50px; color: #555; font-size: 12px; letter-spacing: 2px;
            animation: blink 2s infinite; opacity: 0; animation-delay: 3s; animation-fill-mode: forwards;
        }
        
        @keyframes fadeup { to { opacity: 1; } }
        @keyframes loadLine { to { width: 400px; } }
        @keyframes blink { 0%,100%{opacity:0;} 50%{opacity:1;} }
        @keyframes glitch {
            0% { transform: translate(0); }
            1% { transform: translate(-2px, 2px); filter: hue-rotate(90deg); }
            2% { transform: translate(2px, -2px); filter: hue-rotate(-90deg); }
            3% { transform: translate(0); filter: none; }
        }

        /* --- 2. ARCHITECTURAL UI --- */
        #side-menu {
            position: absolute; top: 0; left: 0; width: 240px; height: 100%;
            background: linear-gradient(90deg, rgba(0,5,10,0.9), rgba(0,5,10,0.6));
            border-right: 1px solid rgba(0,255,255,0.15);
            overflow-y: auto; z-index: 100; padding: 40px 0;
            backdrop-filter: blur(10px);
        }
        .menu-group { margin-bottom: 30px; }
        .menu-header {
            font-size: 10px; color: #00ffff; padding: 5px 25px; letter-spacing: 2px; font-weight: bold;
            border-bottom: 1px solid rgba(0,255,255,0.2); margin-bottom: 8px;
        }
        .menu-item {
            padding: 8px 25px; color: #777; font-size: 11px; cursor: pointer; transition: 0.2s;
            border-left: 3px solid transparent; font-family: 'Consolas', monospace; letter-spacing: 1px;
            display: flex; justify-content: space-between;
        }
        .menu-item:hover { color: #fff; background: rgba(0,255,255,0.05); }
        .menu-item.active { 
            color: #fff; background: rgba(0,255,255,0.1); border-left: 3px solid #00ffff; 
            text-shadow: 0 0 10px rgba(0,255,255,0.5);
        }
        .item-id { font-weight: bold; }

        /* --- 3. LOGIC MONITOR (HUD) --- */
        #hud-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        #logic-monitor {
            position: absolute; bottom: 40px; left: 260px; right: 40px;
            text-align: center; font-family: 'Consolas', monospace;
        }
        .phase-label {
            font-size: 12px; color: #555; letter-spacing: 3px; margin-bottom: 5px; display: block;
        }
        .phase-val {
            font-size: 16px; color: #00ffff; letter-spacing: 2px; 
            text-shadow: 0 0 15px rgba(0,255,255,0.8);
            background: rgba(0,0,0,0.6); padding: 5px 15px; border: 1px solid #004444; display: inline-block;
        }

        /* --- 4. DATA PANEL --- */
        #panel {
            position: absolute; top: 0; right: 0; width: 420px; height: 100%;
            background: rgba(8, 11, 15, 0.96); border-left: 1px solid #333;
            transform: translateX(100%); transition: transform 0.4s cubic-bezier(0.19, 1, 0.22, 1);
            color: #eee; display: flex; flex-direction: column; z-index: 100;
            box-shadow: -30px 0 60px rgba(0,0,0,0.9);
        }
        #panel.active { transform: translateX(0); }
        
        .p-header { 
            padding: 40px 30px 20px; border-bottom: 1px solid rgba(255,255,255,0.1);
            background: linear-gradient(180deg, rgba(0,255,255,0.05), transparent);
        }
        .p-tag { 
            font-size: 10px; background: #00ffff; color: #000; padding: 4px 8px; 
            border-radius: 2px; font-weight: 800; letter-spacing: 1px;
        }
        .p-title { 
            font-size: 32px; margin: 15px 0 5px; color: #fff; font-weight: 300; letter-spacing: 1px;
            text-shadow: 0 0 20px currentColor; 
        }
        .p-body { padding: 30px; overflow-y: auto; flex: 1; }
        
        .data-section { margin-bottom: 30px; }
        .data-label { 
            font-size: 10px; color: #00ffff; letter-spacing: 2px; margin-bottom: 8px; 
            border-bottom: 1px solid #333; padding-bottom: 3px; display: block;
        }
        .data-text { font-size: 13px; line-height: 1.8; color: #ccc; }
        .data-highlight { 
            font-size: 14px; color: #fff; font-family: 'Consolas', monospace; 
            background: rgba(255,255,255,0.05); padding: 15px; border-radius: 4px;
            border-left: 3px solid #00ffff;
        }

        .close-btn { 
            position: absolute; top: 20px; right: 20px; font-size: 24px; color: #555; 
            cursor: pointer; transition: 0.2s; 
        }
        .close-btn:hover { color: #fff; }

        /* Responsive */
        @media(max-width: 900px) {
            #side-menu { width: 60px; }
            .menu-item span:last-child { display: none; } /* Hide text keep ID */
            .menu-header { display: none; }
            #panel { width: 100%; }
            #logic-monitor { left: 10px; right: 10px; bottom: 20px; }
        }
    </style>

    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

    <div id="loader" onclick="startSystem()">
        <div class="logo-box">
            <h1 class="logo-text">SONALIA</h1>
            <div class="logo-sub">LOGIC ARCHITECTURE v1.0</div>
            <div class="loading-line"></div>
            <div class="start-hint">[ CLICK TO INITIALIZE ]</div>
        </div>
    </div>

    <div id="side-menu">
        <div class="menu-group">
            <div class="menu-header">/// 8 OS (LENS)</div>
            <div id="list-os"></div>
        </div>
        <div class="menu-group">
            <div class="menu-header">/// 8 FACTORS (VECTOR)</div>
            <div id="list-coef"></div>
        </div>
        <div class="menu-group">
            <div class="menu-header">/// 4 DB (MEMORY)</div>
            <div id="list-db"></div>
        </div>
    </div>

    <div id="hud-layer">
        <div id="logic-monitor">
            <span class="phase-label" id="phase-lbl">SYSTEM STATUS</span>
            <div class="phase-val" id="phase-val">STANDBY</div>
        </div>
    </div>

    <div id="panel">
        <div class="close-btn" id="p-close">×</div>
        <div class="p-header">
            <span class="p-tag" id="p-tag">TAG</span>
            <h2 class="p-title" id="p-title">Title</h2>
        </div>
        <div class="p-body">
            <div class="data-section">
                <span class="data-label">DEFINITION</span>
                <div class="data-text" id="p-desc">...</div>
            </div>
            <div class="data-section">
                <span class="data-label">FUNCTION ROLE</span>
                <div class="data-text" id="p-role">...</div>
            </div>
            <div class="data-section">
                <span class="data-label">INTERNAL THOUGHT (VOICE)</span>
                <div class="data-highlight" id="p-thought">...</div>
            </div>
        </div>
    </div>

    <script>
        // 強制スタート機能
        function startSystem() {
            const l = document.getElementById('loader');
            l.style.opacity = 0;
            setTimeout(() => { l.style.display = 'none'; }, 1000);
        }

        // ==========================================
        // 0. SONALIA LOGIC DATA (Full Definition)
        // ==========================================
        const DATA = {
            OS: [
                { id: "SURVIVAL", name: "生存OS", color: 0xFF3333, 
                  desc: "【危険 ↔ 安全】を判断するレンズ。最優先でリスクを回避し、生命と生活の維持を図る。原始的かつ強力な防衛本能。",
                  role: "リスクマネジメント・安全確保", thought: "「これは危なくないか？最悪どうなる？」" },
                { id: "LIFE",     name: "生活OS", color: 0x33FF33, 
                  desc: "【既知 ↔ 未知】を判断するレンズ。ルーティンの維持、あるいは新しい変化への適応を司る。日常の安定装置。",
                  role: "習慣維持・環境適応", thought: "「いつものパターンか？新しい体験か？」" },
                { id: "EVAL",     name: "評価OS", color: 0x3388FF, 
                  desc: "【善 ↔ 悪 / 正 ↔ 誤】を判断するレンズ。正義、ルール、マナー、道徳的に正しいかを採点する超自我。",
                  role: "善悪判断・規律維持", thought: "「それは正しいことか？許されるのか？」" },
                { id: "BELONG",   name: "所属OS", color: 0xFF8833, 
                  desc: "【内 ↔ 外】を判断するレンズ。集団の中にいるか、仲間外れになっていないかを確認する社会的本能。",
                  role: "集団帰属・疎外感回避", thought: "「ここにいていいのか？浮いていないか？」" },
                { id: "REWARD",   name: "報酬OS", color: 0xFFD700, 
                  desc: "【損 ↔ 得】を判断するレンズ。コストパフォーマンス、利益、時間的メリットを計算する合理性。",
                  role: "損得勘定・効率化", thought: "「やる価値はあるか？元は取れるか？」" },
                { id: "MEANING",  name: "意味OS", color: 0x9933FF, 
                  desc: "【意義 ↔ 無意味】を判断するレンズ。自分の人生にとって意味があるか、誇れるかを問う自己実現欲求。",
                  role: "意義の探求・物語化", thought: "「自分にとってどんな意味がある？誇れるか？」" },
                { id: "TIME",     name: "時間OS", color: 0x00FFFF, 
                  desc: "【過去 ↔ 未来】を判断するレンズ。過去の経験則（後悔）か、未来の予測（不安・希望）か、時間軸で捉える。",
                  role: "過去参照・未来予測", thought: "「前もこうだった」「将来どうなる？」" },
                { id: "HARMONY",  name: "協調OS", color: 0xFF66AA, 
                  desc: "【自分 ↔ 他人】を判断するレンズ。自分の意志を通すか、全体のために譲るかのバランス調整機能。",
                  role: "利害調整・調和", thought: "「相手はどう思う？自分が譲るべきか？」" }
            ],
            COEF: [
                { id: "IQ", name: "IQ (論理)", color: 0x00CCFF, desc: "情報を整理・構造化し、筋道を立てる力。", role: "Logic Processing", thought: "分析・分解・再構築" },
                { id: "EQ", name: "EQ (感情)", color: 0xFF6666, desc: "自分と他人の感情を察知し、扱う力。", role: "Empathy Engine", thought: "共感・配慮・感情理解" },
                { id: "SQ", name: "SQ (社会)", color: 0xFFCC00, desc: "関係性をつくり、維持し、場に適応する力。", role: "Social Adaptor", thought: "適応・人脈・交渉" },
                { id: "AQ", name: "AQ (逆境)", color: 0x888888, desc: "ストレス・困難に対する粘りと回復力。", role: "Resilience Core", thought: "耐久・回復・忍耐" },
                { id: "CQ", name: "CQ (創造)", color: 0xAA00FF, desc: "新しいものへの好奇心と発想・工夫を生む力。", role: "Idea Generator", thought: "好奇心・発想・着眼" },
                { id: "HQ", name: "HQ (人間)", color: 0xFFFFFF, desc: "公平さ・誠実さ・倫理観・信頼性を保つ力。", role: "Ethical Anchor", thought: "誠実・公平・信頼" },
                { id: "MQ", name: "MQ (行動)", color: 0xFF3300, desc: "考えたことを実際の行動に移すスピードと量。", role: "Action Driver", thought: "即断・即決・実行" },
                { id: "KQ", name: "KQ (知識)", color: 0x00FF88, desc: "知識・経験を必要な場面で取り出して使う力。", role: "Knowledge Base", thought: "応用・転用・参照" }
            ],
            DB: [
                { id:"DESIRE", name: "欲求DB", color: 0xFF5500, desc: "「〜したい」「〜されたい」という根源的渇望。\n承認欲求、安全欲求など行動の源泉。", role: "Motivation Drive", thought: "Deep Desire / Craving" },
                { id:"EMOTION", name: "情動DB", color: 0x0055FF, desc: "「快・不快」「恐怖・安心」などの感情記憶。\n過去の体験に基づく直感的な反応。", role: "Affective Memory", thought: "Emotional Flashback" },
                { id:"VALUE", name: "価値観DB", color: 0xFFD700, desc: "「〜すべき」「〜あるべき」という信念体系。\n親や社会から刷り込まれた判断ルール。", role: "Belief System", thought: "Core Rules / Dogma" },
                { id:"IMPLICIT", name: "無意識DB", color: 0x666666, desc: "習慣、癖、反射的に取ってしまう行動パターン。\n思考を介さずに自動実行されるスクリプト。", role: "Auto-Pilot Scripts", thought: "Habits / Reflex" }
            ]
        };

        // ==========================================
        // 1. SCENE SETUP
        // ==========================================
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.001);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 3000);
        camera.position.set(0, 40, 300);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.4;

        // Assets
        function createGlowTexture() {
            const c = document.createElement('canvas'); c.width=64; c.height=64;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(32,32,0, 32,32,32);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(0.2, 'rgba(255,255,255,0.2)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(c);
        }
        const glowTex = createGlowTexture();
        const interactables = [];
        const idMap = {}; // ID -> Object mapping

        const mainGroup = new THREE.Group();
        scene.add(mainGroup);

        // ==========================================
        // 2. ARCHITECTURE CONSTRUCTION
        // ==========================================

        // --- A. CENTRAL PROCESSING UNIT (OS CORE) ---
        const osGroup = new THREE.Group();
        mainGroup.add(osGroup);

        // Brain Wireframe
        const coreGeo = new THREE.IcosahedronGeometry(18, 2);
        const coreMat = new THREE.MeshBasicMaterial({ color: 0x0044aa, wireframe: true, transparent: true, opacity: 0.1 });
        const coreMesh = new THREE.Mesh(coreGeo, coreMat);
        osGroup.add(coreMesh);

        DATA.OS.forEach((d, i) => {
            // Sphere placement
            const phi = Math.acos( -1 + ( 2 * i ) / 8 );
            const theta = Math.sqrt( 8 * Math.PI ) * phi;
            const r = 24;
            const x = r * Math.cos(theta) * Math.sin(phi);
            const y = r * Math.sin(theta) * Math.sin(phi);
            const z = r * Math.cos(phi);
            const pos = new THREE.Vector3(x, y, z);

            const mesh = new THREE.Mesh(new THREE.SphereGeometry(3), new THREE.MeshBasicMaterial({ color: d.color }));
            mesh.position.copy(pos);
            mesh.userData = { type: 'OS', data: d };
            
            const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: glowTex, color: d.color, blending: THREE.AdditiveBlending }));
            spr.scale.set(30,30,1);
            mesh.add(spr);

            osGroup.add(mesh);
            interactables.push(mesh);
            idMap[d.id] = mesh;
        });

        // --- B. VECTOR ENGINES (COEFFICIENTS) ---
        const coefGroup = new THREE.Group();
        mainGroup.add(coefGroup);
        const coefObjs = [];

        DATA.COEF.forEach((d, i) => {
            const angle = (i / 8) * Math.PI * 2;
            const rad = 85;
            const x = Math.cos(angle) * rad;
            const z = Math.sin(angle) * rad;
            const pos = new THREE.Vector3(x, 0, z);

            const mesh = new THREE.Mesh(new THREE.BoxGeometry(6,6,6), new THREE.MeshBasicMaterial({ color: d.color, wireframe: true }));
            mesh.position.copy(pos);
            mesh.userData = { type: 'COEF', data: d };

            const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: glowTex, color: d.color, blending: THREE.AdditiveBlending }));
            spr.scale.set(45,45,1);
            mesh.add(spr);

            coefGroup.add(mesh);
            interactables.push(mesh);
            coefObjs.push(mesh);
            idMap[d.id] = mesh;
        });

        // --- C. NEURAL CABLES (OS <-> COEF) ---
        const cableGroup = new THREE.Group();
        mainGroup.add(cableGroup);

        coefObjs.forEach(target => {
            const start = new THREE.Vector3(0,0,0);
            const end = target.position;
            const mid = start.clone().lerp(end, 0.5);
            mid.y += 25; // Arch

            const curve = new THREE.QuadraticBezierCurve3(start, mid, end);
            const pts = curve.getPoints(20);
            const geo = new THREE.BufferGeometry().setFromPoints(pts);
            const mat = new THREE.LineBasicMaterial({ 
                color: target.userData.data.color, 
                transparent: true, opacity: 0.4 
            });
            const cable = new THREE.Line(geo, mat);
            cableGroup.add(cable);
        });

        // --- D. DEEP MEMORY (DB) ---
        const dbGroup = new THREE.Group();
        mainGroup.add(dbGroup);

        DATA.DB.forEach((d, i) => {
            // Deep Position
            const angle = (i/4) * Math.PI * 2;
            const r = 50;
            const x = Math.cos(angle)*r;
            const z = Math.sin(angle)*r;
            const pos = new THREE.Vector3(x, -80, z);

            // Cloud
            const pGeo = new THREE.Geometry();
            for(let k=0; k<150; k++) {
                const spread=30;
                pGeo.vertices.push(new THREE.Vector3(
                    pos.x+(Math.random()-0.5)*spread,
                    pos.y+(Math.random()-0.5)*spread,
                    pos.z+(Math.random()-0.5)*spread
                ));
            }
            const pMat = new THREE.PointsMaterial({ color: d.color, size:2, map:glowTex, transparent:true, opacity:0.6, blending:THREE.AdditiveBlending, depthWrite:false });
            const cloud = new THREE.Points(pGeo, pMat);
            dbGroup.add(cloud);

            // Connection to Brain
            const lineGeo = new THREE.Geometry();
            lineGeo.vertices.push(new THREE.Vector3(0,-20,0), pos);
            const lineMat = new THREE.LineBasicMaterial({ color: d.color, transparent:true, opacity:0.15 });
            dbGroup.add(new THREE.Line(lineGeo, lineMat));

            // Hitbox
            const box = new THREE.Mesh(new THREE.BoxGeometry(40,40,40), new THREE.MeshBasicMaterial({visible:false}));
            box.position.copy(pos);
            box.userData = { type: 'DB', data: d };
            interactables.push(box);
            idMap[d.id] = box;
        });

        // --- E. LOGIC PULSE ---
        const pulse = new THREE.Mesh(new THREE.SphereGeometry(2), new THREE.MeshBasicMaterial({color:0xffffff}));
        const pulseSpr = new THREE.Sprite(new THREE.SpriteMaterial({map: glowTex, color: 0xffffff, blending: THREE.AdditiveBlending}));
        pulseSpr.scale.set(25,25,1);
        pulse.add(pulseSpr);
        scene.add(pulse);


        // ==========================================
        // 3. UI GENERATION
        // ==========================================
        function createMenu(containerId, list) {
            const container = document.getElementById(containerId);
            list.forEach(d => {
                const div = document.createElement('div');
                div.className = 'menu-item';
                div.innerHTML = `<span class="item-id">${d.id}</span><span>${d.name}</span>`;
                div.onclick = () => selectItem(d.id, d.color);
                container.appendChild(div);
            });
        }
        createMenu('list-os', DATA.OS);
        createMenu('list-coef', DATA.COEF);
        createMenu('list-db', DATA.DB);

        // ==========================================
        // 4. ANIMATION & LOGIC LOOP
        // ==========================================
        const clock = new THREE.Clock();
        const lblPhase = document.getElementById('phase-lbl');
        const valPhase = document.getElementById('phase-val');

        // 自動で消える処理も念のため残す
        setTimeout(() => {
            const l = document.getElementById('loader');
            // クリックされずに4秒経ったら自動で消す
            if(l.style.display !== 'none') startSystem();
        }, 4000);

        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            if(controls) controls.update();
            const delta = clock.getElapsedTime();

            // Organic Breathing
            const beat = 1 + Math.sin(delta*2)*0.03;
            osGroup.scale.set(beat, beat, beat);
            cableGroup.scale.set(beat, beat, beat);
            
            osGroup.rotation.y = Math.sin(delta*0.1)*0.1;
            coefGroup.rotation.y = delta * -0.1;
            cableGroup.rotation.y = delta * -0.1;

            // --- SONALIA LOGIC LOOP (4 Phases) ---
            const loopLen = 8.0;
            const t = delta % loopLen;
            let target = new THREE.Vector3();
            let col = 0xffffff;
            let pLabel = "SYSTEM IDLE";
            let pVal = "...";

            if (t < 1.5) {
                // PHASE 1: PERCEPTION (INPUT)
                let p = t/1.5;
                target.set(0, 180*(1-p), 120*(1-p));
                col = 0xffffff;
                pLabel = "PHASE 01: INPUT LAYER";
                pVal = "PERCEPTION";
            } else if (t < 3.5) {
                // PHASE 2: MEANING & MEMORY (OS -> DB)
                let p = (t-1.5)/2.0;
                let db = new THREE.Vector3(0,-80,0);
                if(p<0.5) target.lerpVectors(new THREE.Vector3(), db, p*2);
                else target.lerpVectors(db, new THREE.Vector3(), (p-0.5)*2);
                col = 0x0055FF;
                pLabel = "PHASE 02: OS & DB";
                pVal = "MEANING ASSIGNMENT";
            } else if (t < 5.5) {
                // PHASE 3: VECTOR CALCULATION (COEF)
                let p = (t-3.5)/2.0;
                target.lerpVectors(new THREE.Vector3(), new THREE.Vector3(85,0,0), p);
                col = 0x00CCFF;
                pLabel = "PHASE 03: VECTOR LAYER";
                pVal = "FACTOR CALCULATION";
            } else {
                // PHASE 4: OUTPUT
                let p = (t-5.5)/2.5;
                target.lerpVectors(new THREE.Vector3(85,0,0), new THREE.Vector3(300,0,0), p);
                col = 0xFF3300;
                pLabel = "PHASE 04: OUTPUT LAYER";
                pVal = "BEHAVIOR EXECUTION";
            }

            pulse.position.copy(target);
            pulse.material.color.setHex(col);
            pulseSpr.material.color.setHex(col);
            
            lblPhase.innerText = pLabel;
            valPhase.innerText = pVal;
            valPhase.style.color = '#' + col.toString(16).padStart(6,'0');
            valPhase.style.textShadow = `0 0 15px #${col.toString(16).padStart(6,'0')}`;
            valPhase.style.borderColor = '#' + col.toString(16).padStart(6,'0');

            renderer.render(scene, camera);
        }
        animate();

        // ==========================================
        // 5. INTERACTION Logic
        // ==========================================
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function selectItem(id, color) {
            // Highlight Menu
            document.querySelectorAll('.menu-item').forEach(e => e.classList.remove('active'));
            // Find Dom by text is hard, just use logic if needed, or simple visual feedback in 3D
            
            const obj = idMap[id];
            if(obj) {
                showPanel(obj.userData);
                // Camera FlyTo
                const endPos = obj.position.clone().normalize().multiplyScalar(150);
                endPos.y += 30;
                new TWEEN.Tween(camera.position)
                    .to({x: endPos.x, y: endPos.y, z: endPos.z}, 1200)
                    .easing(TWEEN.Easing.Cubic.Out)
                    .start();
            }
        }

        window.addEventListener('mousedown', (e) => {
            if(e.clientX < 240) return; // Ignore menu area
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(interactables);
            if(hits.length > 0) {
                const ud = hits[0].object.userData;
                selectItem(ud.data.id, ud.data.color);
            } else {
                hidePanel();
            }
        });

        const pClose = document.getElementById('p-close');
        pClose.onclick = hidePanel;
        
        function showPanel(ud) {
            const d = ud.data;
            document.getElementById('p-tag').innerText = ud.type;
            document.getElementById('p-title').innerText = d.name;
            document.getElementById('p-title').style.color = '#' + new THREE.Color(d.color).getHexString();
            document.getElementById('p-desc').innerText = d.desc;
            document.getElementById('p-role').innerText = d.role;
            document.getElementById('p-thought').innerText = d.thought;
            
            document.getElementById('panel').classList.add('active');
        }
        function hidePanel() {
            document.getElementById('panel').classList.remove('active');
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
