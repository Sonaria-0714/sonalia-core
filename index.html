<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sonalia System: Neural Fabric</title>
    <style>
        /* --- 没入感を高めるスタイル --- */
        body { margin: 0; overflow: hidden; background-color: #010103; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }

        /* UIレイヤー */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; z-index: 10;
        }

        /* 左上：システムモニタ */
        #hud-left { padding: 30px; }
        .hud-title {
            color: #fff; font-size: 14px; letter-spacing: 3px; border-left: 3px solid #00ffff;
            padding-left: 10px; margin-bottom: 10px; text-transform: uppercase;
            text-shadow: 0 0 10px rgba(0,255,255,0.5);
        }
        .hud-row {
            color: rgba(255,255,255,0.6); font-family: 'Consolas', monospace; font-size: 11px;
            margin-bottom: 4px; display: flex; align-items: center; gap: 10px;
        }
        .status-dot { width: 8px; height: 8px; background: #00ff00; border-radius: 50%; box-shadow: 0 0 5px #00ff00; }

        /* 中央下：ロジックフロー表示 */
        #logic-flow {
            text-align: center; padding-bottom: 40px;
            font-family: 'Consolas', monospace; font-size: 16px; letter-spacing: 1px;
            text-shadow: 0 0 15px currentColor; transition: color 0.3s;
        }

        /* 右側：詳細パネル（グラスモーフィズム） */
        #panel {
            position: absolute; top: 0; right: 0; width: 400px; height: 100%;
            background: rgba(10, 15, 25, 0.7); /* 少し暗く */
            backdrop-filter: blur(25px); /* ぼかし強化 */
            -webkit-backdrop-filter: blur(25px);
            border-left: 1px solid rgba(255, 255, 255, 0.15);
            transform: translateX(100%); transition: transform 0.5s cubic-bezier(0.23, 1, 0.32, 1);
            pointer-events: auto; display: flex; flex-direction: column;
            box-shadow: -20px 0 80px rgba(0,0,0,0.6);
        }
        #panel.active { transform: translateX(0); }

        .panel-inner { padding: 40px; overflow-y: auto; color: #eee; }
        .tag {
            display: inline-block; font-size: 10px; font-weight: 700; padding: 4px 8px; 
            border-radius: 2px; color: #000; background: #fff; margin-bottom: 15px; letter-spacing: 1px;
        }
        h2 { margin: 0 0 20px 0; font-size: 28px; font-weight: 300; letter-spacing: 1px; color: #fff; text-shadow: 0 0 20px rgba(255,255,255,0.3); }
        p { font-size: 14px; line-height: 1.8; color: #ccc; margin-bottom: 30px; font-weight: 400; }
        
        /* データ可視化風の装飾 */
        .data-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 20px; }
        .data-item { background: rgba(255,255,255,0.05); padding: 10px; border-radius: 4px; }
        .data-label { font-size: 10px; color: #888; display: block; margin-bottom: 3px; }
        .data-val { font-size: 12px; color: #fff; font-family: 'Consolas', monospace; }

        .close-btn {
            position: absolute; top: 20px; right: 20px; width: 30px; height: 30px;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            border: 1px solid rgba(255,255,255,0.2); border-radius: 50%; transition: 0.3s; color: #fff;
        }
        .close-btn:hover { background: rgba(255,255,255,0.1); border-color: #fff; }

        /* ローディング画面 */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 9999;
            display: flex; align-items: center; justify-content: center; flex-direction: column;
            transition: opacity 1s ease-out; pointer-events: none;
        }
        .loader-text { color: #00ffff; font-family: monospace; letter-spacing: 5px; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loader"><div class="loader-text">BUILDING NEURAL PATHWAYS...</div></div>

    <div id="ui-layer">
        <div id="hud-left">
            <div class="hud-title">Sonalia Logic Core</div>
            <div class="hud-row"><div class="status-dot"></div> SYSTEM ONLINE</div>
            <div class="hud-row">ARCHITECTURE: NEURAL FABRIC v3.0</div>
            <div class="hud-row">MODE: FULL SYNAPTIC CONNECTION</div>
        </div>
        <div id="logic-flow">WAITING FOR SIGNAL...</div>
    </div>

    <div id="panel">
        <div class="close-btn" id="p-close">✕</div>
        <div class="panel-inner">
            <span class="tag" id="p-tag">CATEGORY</span>
            <h2 id="p-title">Title</h2>
            <p id="p-desc">Description text here.</p>
            
            <div class="data-grid">
                <div class="data-item">
                    <span class="data-label">ROLE</span>
                    <span class="data-val" id="p-role">Analysis</span>
                </div>
                <div class="data-item">
                    <span class="data-label">CONNECTION</span>
                    <span class="data-val" id="p-conn">Active</span>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ==========================================
        // 1. SONALIA DATA DEFINITION
        // ==========================================
        const DATA = {
            OS: [
                { id: "SURVIVAL", name: "生存OS", color: 0xFF3333, desc: "【危険 ↔ 安全】\n最優先でリスクを回避し、生命維持と安全確保を図る判断基準。", role: "Risk Management" },
                { id: "LIFE",     name: "生活OS", color: 0x33FF33, desc: "【既知 ↔ 未知】\nルーティンの維持、あるいは新しい変化への適応を判断する。", role: "Routine / Adapt" },
                { id: "EVAL",     name: "評価OS", color: 0x3388FF, desc: "【善 ↔ 悪】\n正義、ルール、マナー、道徳的に正しいかを採点する。", role: "Judgment" },
                { id: "BELONG",   name: "所属OS", color: 0xFF8833, desc: "【内 ↔ 外】\n集団の中にいるか、仲間外れになっていないかを確認する。", role: "Social Safety" },
                { id: "REWARD",   name: "報酬OS", color: 0xFFD700, desc: "【損 ↔ 得】\nコストパフォーマンス、利益、メリットがあるかを計算する。", role: "Cost / Benefit" },
                { id: "MEANING",  name: "意味OS", color: 0x9933FF, desc: "【意義 ↔ 無意味】\n自分の人生にとって意味があるか、誇れるかを問う。", role: "Purpose" },
                { id: "TIME",     name: "時間OS", color: 0x00FFFF, desc: "【過去 ↔ 未来】\n過去の経験則に基づくか、未来の予測に基づくか。", role: "Prediction" },
                { id: "HARMONY",  name: "協調OS", color: 0xFF66AA, desc: "【自分 ↔ 他人】\n自分を通すか、全体のために譲るかのバランス調整。", role: "Coordination" }
            ],
            COEF: [
                { id: "IQ", name: "IQ (論理)", color: 0x00CCFF, desc: "情報を構造化し、ロジックを組む力。", role: "Logic Processing" },
                { id: "EQ", name: "EQ (感情)", color: 0xFF6666, desc: "感情を読み取り、配慮する力。", role: "Empathy Engine" },
                { id: "SQ", name: "SQ (社会)", color: 0xFFCC00, desc: "人間関係を構築し、場に適応する力。", role: "Social Networking" },
                { id: "AQ", name: "AQ (逆境)", color: 0x888888, desc: "ストレスや失敗から立ち直る力。", role: "Resilience" },
                { id: "CQ", name: "CQ (創造)", color: 0xAA00FF, desc: "新しいアイデアや工夫を生む力。", role: "Innovation" },
                { id: "HQ", name: "HQ (人間)", color: 0xFFFFFF, desc: "誠実さや公平さを保つ倫理観。", role: "Ethics Core" },
                { id: "MQ", name: "MQ (行動)", color: 0xFF3300, desc: "思考を実行に移すスピードと量。", role: "Action Driver" },
                { id: "KQ", name: "KQ (知識)", color: 0x00FF88, desc: "過去の経験を引き出して活用する力。", role: "Knowledge Base" }
            ],
            DB: [
                { id: "DESIRE", name: "欲求DB", color: 0xFF5500, pos: [-100, 70, -70], desc: "根源的な欲求の記憶領域。", role: "Core Drive" },
                { id: "EMOTION", name: "情動DB", color: 0x0055FF, pos: [100, 70, -70], desc: "快・不快の感情記憶領域。", role: "Affective Memory" },
                { id: "VALUE", name: "価値観DB", color: 0xFFD700, pos: [-100, -70, -70], desc: "信念・ルールのデータベース。", role: "Belief System" },
                { id: "IMPLICIT", name: "無意識DB", color: 0x666666, pos: [100, -70, -70], desc: "習慣や反射行動のログ。", role: "Auto Pilot" }
            ]
        };

        // ==========================================
        // 2. HIGH-END SCENE SETUP
        // ==========================================
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x010103, 0.002); // より深い黒

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 3000);
        camera.position.set(0, 40, 280);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        renderer.toneMapping = THREE.ACESFilmicToneMapping; // 映画のようなトーンマッピング
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true; // ゆっくり回転させる
        controls.autoRotateSpeed = 0.3;

        // --- POST-PROCESSING (THE BLOOM) ---
        const renderScene = new RenderPass(scene, camera);
        // ブルームを少し強めに調整
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.8, 0.5, 0.9);
        
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // マテリアルヘルパー
        function createGlowMat(colorHex, opacity = 1.0) {
            return new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(colorHex).multiplyScalar(2.0), // 強度2倍で発光
                transparent: true, 
                opacity: opacity,
                blending: THREE.AdditiveBlending,
                depthWrite: false // 重なった時に光が混ざるようにする
            });
        }
        function createWireMat(colorHex, opacity = 0.3) {
             return new THREE.LineBasicMaterial({
                color: new THREE.Color(colorHex).multiplyScalar(1.5),
                transparent: true,
                opacity: opacity,
                blending: THREE.AdditiveBlending
            });
        }

        const interactables = [];
        const allNodes = []; // 全ノードの位置を保存して接続に使う

        // ==========================================
        // 3. OBJECT GENERATION (NEURAL FABRIC)
        // ==========================================
        
        const mainGroup = new THREE.Group();
        scene.add(mainGroup);

        // A. THE BRAIN CORE (OS)
        const osGroup = new THREE.Group();
        mainGroup.add(osGroup);

        // 脳の核（複雑なワイヤーフレーム）
        const coreGeo = new THREE.IcosahedronGeometry(18, 3);
        const pos = coreGeo.attributes.position;
        for(let i=0; i<pos.count; i++){
            const noise = 1 + Math.random()*0.15;
            pos.setXYZ(i, pos.getX(i)*noise, pos.getY(i)*noise, pos.getZ(i)*noise);
        }
        // 内部の複雑な神経網
        const coreMat = createWireMat(0x0088ff, 0.1);
        const coreMesh = new THREE.Mesh(coreGeo, coreMat);
        osGroup.add(coreMesh);
        
        // 8 OS Nodes
        DATA.OS.forEach((d, i) => {
            const phi = Math.acos( -1 + ( 2 * i ) / 8 );
            const theta = Math.sqrt( 8 * Math.PI ) * phi;
            const r = 22;
            const x = r * Math.cos(theta) * Math.sin(phi);
            const y = r * Math.sin(theta) * Math.sin(phi);
            const z = r * Math.cos(phi);
            const nodePos = new THREE.Vector3(x, y, z);

            // ノード
            const mesh = new THREE.Mesh(new THREE.IcosahedronGeometry(3, 1), createGlowMat(d.color));
            mesh.position.copy(nodePos);
            mesh.userData = { type: 'OS', data: d };
            
            // グロー
            const glow = new THREE.Sprite(new THREE.SpriteMaterial({ map: createGlowTexture(), color: d.color, blending: THREE.AdditiveBlending }));
            glow.scale.set(25, 25, 1);
            mesh.add(glow);

            osGroup.add(mesh);
            interactables.push(mesh);
            allNodes.push({ pos: nodePos.clone(), color: d.color, group: 'OS' });
        });


        // B. COEFFICIENTS (Satellites)
        const coefGroup = new THREE.Group();
        mainGroup.add(coefGroup);
        const coefMeshes = [];

        DATA.COEF.forEach((d, i) => {
            const angle = (i / 8) * Math.PI * 2;
            const rad = 75;
            const x = Math.cos(angle) * rad;
            const z = Math.sin(angle) * rad;
            const nodePos = new THREE.Vector3(x, 0, z);

            // テクノロジー感のあるキューブ
            const geo = new THREE.BoxGeometry(5, 5, 5);
            const edges = new THREE.EdgesGeometry(geo);
            const line = new THREE.LineSegments(edges, createWireMat(d.color, 0.8));
            
            const inner = new THREE.Mesh(new THREE.BoxGeometry(3.5,3.5,3.5), createGlowMat(d.color, 0.6));

            const group = new THREE.Group();
            group.add(line);
            group.add(inner);
            group.position.copy(nodePos);
            group.userData = { type: 'COEF', data: d };

            // 係数用の強いグロー
            const glow = new THREE.Sprite(new THREE.SpriteMaterial({ map: createGlowTexture(), color: d.color, blending: THREE.AdditiveBlending, opacity: 0.5 }));
            glow.scale.set(40, 40, 1);
            group.add(glow);

            coefGroup.add(group);
            interactables.push(group);
            coefMeshes.push(group);
            allNodes.push({ pos: nodePos.clone(), color: d.color, group: 'COEF' });
        });


        // C. DB CLOUDS (Particles)
        const dbGroup = new THREE.Group();
        mainGroup.add(dbGroup);

        DATA.DB.forEach(d => {
            const pCount = 400; // 粒子数
            const pGeo = new THREE.BufferGeometry();
            const pPos = [];
            
            for(let i=0; i<pCount; i++) {
                const spread = 50;
                const v = new THREE.Vector3(
                    d.pos[0] + (Math.random()-0.5)*spread,
                    d.pos[1] + (Math.random()-0.5)*spread,
                    d.pos[2] + (Math.random()-0.5)*spread
                );
                pPos.push(v.x, v.y, v.z);
                // 一部の粒子を接続候補に追加（全部だと重すぎるため間引く）
                if(Math.random() > 0.95) {
                     allNodes.push({ pos: v.clone(), color: d.color, group: 'DB' });
                }
            }
            pGeo.setAttribute('position', new THREE.Float32BufferAttribute(pPos, 3));
            const pMat = new THREE.PointsMaterial({ 
                color: new THREE.Color(d.color).multiplyScalar(1.5),
                size: 2.0, 
                transparent: true, opacity: 0.6,
                map: createGlowTexture(),
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const pts = new THREE.Points(pGeo, pMat);
            dbGroup.add(pts);

            // 判定用透明ボックス
            const box = new THREE.Mesh(new THREE.BoxGeometry(60,60,60), new THREE.MeshBasicMaterial({visible:false}));
            box.position.set(d.pos[0], d.pos[1], d.pos[2]);
            box.userData = { type: 'DB', data: d };
            interactables.push(box);
            dbGroup.add(box);
        });

        // --- NEW: 神経回路（シナプス）の生成 ---
        // すべてのノード間を、距離に応じて細い線で結ぶ
        const connectionsGeo = new THREE.BufferGeometry();
        const connectionPos = [];
        const connectionColors = [];
        const maxDist = 90; // 接続する最大距離

        for(let i=0; i<allNodes.length; i++) {
            for(let j=i+1; j<allNodes.length; j++) {
                const n1 = allNodes[i];
                const n2 = allNodes[j];
                const dist = n1.pos.distanceTo(n2.pos);

                // 近くのノード、またはグループが違うノード（OSと係数など）を優先的に繋ぐ
                if(dist < maxDist && (dist < 30 || n1.group !== n2.group)) {
                    connectionPos.push(n1.pos.x, n1.pos.y, n1.pos.z);
                    connectionPos.push(n2.pos.x, n2.pos.y, n2.pos.z);
                    
                    // 色を混ぜる
                    const c1 = new THREE.Color(n1.color);
                    const c2 = new THREE.Color(n2.color);
                    connectionColors.push(c1.r, c1.g, c1.b);
                    connectionColors.push(c2.r, c2.g, c2.b);
                }
            }
        }
        connectionsGeo.setAttribute('position', new THREE.Float32BufferAttribute(connectionPos, 3));
        connectionsGeo.setAttribute('color', new THREE.Float32BufferAttribute(connectionColors, 3));
        
        const synapticMat = new THREE.LineBasicMaterial({
            vertexColors: true, // 頂点カラーを使用
            transparent: true,
            opacity: 0.15, // 薄く表示
            blending: THREE.AdditiveBlending
        });
        const synapticNet = new THREE.LineSegments(connectionsGeo, synapticMat);
        mainGroup.add(synapticNet);
        
        // OSと係数をつなぐ太いエネルギーチューブ
        coefMeshes.forEach(cm => {
            const curve = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(0,0,0), // Start (OS Core)
                new THREE.Vector3(cm.position.x/2, 30, cm.position.z/2), // Control Point (上にあげる)
                cm.position // End (Coefficient)
            );
            const tubeGeo = new THREE.TubeGeometry(curve, 20, 0.5, 8, false);
            const tubeMat = createGlowMat(cm.userData.data.color, 0.3);
            const tube = new THREE.Mesh(tubeGeo, tubeMat);
            mainGroup.add(tube);
        });


        // D. LOGIC PULSE (The Energy Ball)
        const pulse = new THREE.Mesh(new THREE.SphereGeometry(2.5), new THREE.MeshBasicMaterial({ color: 0xffffff }));
        const pulseGlow = new THREE.Sprite(new THREE.SpriteMaterial({map: createGlowTexture(), color: 0xffffff, blending: THREE.AdditiveBlending}));
        pulseGlow.scale.set(15,15,1);
        pulse.add(pulseGlow);
        scene.add(pulse);
        // トレイル
        const trailLength = 30;
        const trails = [];
        for(let i=0; i<trailLength; i++) {
            const m = new THREE.Mesh(new THREE.SphereGeometry(2 * (1 - i/trailLength)), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4/(i*0.1+1) }));
            scene.add(m);
            trails.push(m);
        }

        // ==========================================
        // 4. ANIMATION & LOGIC
        // ==========================================
        
        const clock = new THREE.Clock();
        const flowText = document.getElementById('logic-flow');
        const loader = document.getElementById('loader');

        setTimeout(() => {
            loader.style.opacity = 0;
            setTimeout(() => { loader.style.display = 'none'; }, 1000);
        }, 2500); // ローディング時間を少し長く

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            controls.update();

            // 1. 脳の鼓動 (Pulse)
            const heartbeat = 1 + Math.sin(time * 2.5) * 0.03 + Math.sin(time * 8) * 0.01;
            osGroup.scale.set(heartbeat, heartbeat, heartbeat);
            // シナプスネットワークも連動して動かす
            synapticNet.scale.set(heartbeat, heartbeat, heartbeat);

            // 2. 係数の回転
            coefMeshes.forEach((mesh, i) => {
                mesh.rotation.x += 0.01 + i*0.001;
                mesh.rotation.z += 0.02;
                // 上下動
                mesh.position.y = Math.sin(time + i) * 5;
            });

            // 3. DBの揺らぎ
            dbGroup.rotation.y = Math.sin(time * 0.1) * 0.05;
            synapticNet.rotation.y = Math.sin(time * 0.05) * 0.02; // シナプスも揺らす

            // 4. SONALIA LOOP LOGIC
            const loopDuration = 6.0; // 周期を少し長く
            const t = time % loopDuration;
            
            let targetPos = new THREE.Vector3();
            let status = "";
            let colorHex = 0xffffff;

            if (t < 1.5) {
                const p = t / 1.5;
                targetPos.set(0, 180 * (1-p), 120 * (1-p)); 
                status = ">>> SENSORY INPUT DETECTED >>>";
                colorHex = 0xffffff;
            } else if (t < 3.5) {
                const p = (t - 1.5) / 2.0;
                const dbTarget = new THREE.Vector3(100, 70, -70);
                if(p < 0.5) targetPos.lerpVectors(new THREE.Vector3(), dbTarget, p * 2);
                else targetPos.lerpVectors(dbTarget, new THREE.Vector3(), (p - 0.5) * 2);
                status = "::: REFERENCING MEMORY & EMOTION :::";
                colorHex = 0x0055FF;
            } else if (t < 4.5) {
