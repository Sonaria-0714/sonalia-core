<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SONALIA: INPUT VISUALIZER</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }

        /* UIオーバーレイ */
        #ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
        }
        #title {
            position: absolute; top: 30px; left: 30px;
            color: #fff; font-size: 24px; font-weight: bold; letter-spacing: 4px;
            text-shadow: 0 0 10px #00ffff; border-left: 4px solid #00ffff; padding-left: 15px;
        }
        #subtitle {
            font-size: 12px; color: #00ffff; margin-top: 5px; font-family: monospace;
        }
        
        .label {
            position: absolute; color: #88aaff; font-size: 12px; font-family: monospace;
            text-shadow: 0 0 5px #000; transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>

    <div id="ui">
        <div id="title">
            INPUT PROCESS
            <div id="subtitle">五感入力データの流れ</div>
        </div>
    </div>

    <canvas id="c"></canvas>

    <script>
        /**
         * 完全自立型・軽量2D描画エンジン
         * 外部ライブラリを一切使わないため、読み込みエラーは発生しません。
         */
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        let particles = [];
        let mouse = { x: 0, y: 0 };
        
        // 五感の定義
        const SENSES = [
            { id: "VISUAL", label: "視覚 (Vision)", color: "#00ffff", x: 0.15, y: 0.2 },
            { id: "AUDIO",  label: "聴覚 (Auditory)", color: "#00ddff", x: 0.15, y: 0.35 },
            { id: "TACTILE",label: "触覚 (Tactile)",  color: "#00bbff", x: 0.15, y: 0.5 },
            { id: "SMELL",  label: "嗅覚 (Olfactory)",color: "#0099ff", x: 0.15, y: 0.65 },
            { id: "TASTE",  label: "味覚 (Gustatory)",color: "#0077ff", x: 0.15, y: 0.8 }
        ];

        // 初期化
        function init() {
            resize();
            window.addEventListener('resize', resize);
            window.addEventListener('mousemove', e => {
                mouse.x = e.clientX;
                mouse.y = e.clientY;
            });
            loop();
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        // パーティクル生成クラス
        class Particle {
            constructor(sense) {
                this.sense = sense;
                this.reset();
                // ランダムな位置からスタートして自然なバラつきを出す
                this.progress = Math.random(); 
            }

            reset() {
                // 五感の位置（左側）
                this.sx = width * this.sense.x;
                this.sy = height * this.sense.y;
                
                // 脳の位置（右側中央）
                this.tx = width * 0.7; // Target X
                this.ty = height * 0.5; // Target Y
                
                this.x = this.sx;
                this.y = this.sy;
                this.size = Math.random() * 2 + 1;
                this.speed = 0.005 + Math.random() * 0.01;
                this.progress = 0;
                this.wobble = Math.random() * Math.PI * 2;
            }

            update() {
                this.progress += this.speed;
                
                if (this.progress >= 1) {
                    this.reset();
                }

                // イージング（加速しながら吸い込まれる動き）
                const ease = this.progress * this.progress; // 2乗カーブ

                // 直線補間 + 揺らぎ
                this.x = this.sx + (this.tx - this.sx) * ease;
                this.y = this.sy + (this.ty - this.sy) * ease + Math.sin(this.progress * 10 + this.wobble) * (20 * (1-ease));
                
                // マウスインタラクション（視線移動）
                const mx = (mouse.x - width/2) * 0.05;
                const my = (mouse.y - height/2) * 0.05;
                this.x += mx * (1-ease);
                this.y += my * (1-ease);
            }

            draw() {
                // 軌跡を描く（スピード感を出す）
                const tailLength = 20 * this.progress;
                
                // グラデーション作成
                const grad = ctx.createLinearGradient(
                    this.x, this.y, 
                    this.x - tailLength, this.y
                );
                grad.addColorStop(0, this.sense.color);
                grad.addColorStop(1, "rgba(0,0,0,0)");

                ctx.beginPath();
                ctx.strokeStyle = grad;
                ctx.lineWidth = this.size;
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - tailLength, this.y); // 左側に尾を引く
                ctx.stroke();
                
                // 先頭の光
                ctx.beginPath();
                ctx.fillStyle = "#fff";
                ctx.arc(this.x, this.y, this.size/2, 0, Math.PI*2);
                ctx.fill();
            }
        }

        // パーティクル管理
        for(let i=0; i<150; i++) {
            // ランダムな感覚から発生させる
            const s = SENSES[Math.floor(Math.random() * SENSES.length)];
            particles.push(new Particle(s));
        }

        // メインループ
        function loop() {
            // 画面クリア（少し残像を残す）
            ctx.fillStyle = "rgba(5, 5, 10, 0.2)";
            ctx.fillRect(0, 0, width, height);

            // 1. 五感ノードの描画（左側の発信源）
            SENSES.forEach(s => {
                const x = width * s.x + (mouse.x - width/2)*0.02;
                const y = height * s.y + (mouse.y - height/2)*0.02;
                
                // 光彩
                const glow = ctx.createRadialGradient(x, y, 0, x, y, 40);
                glow.addColorStop(0, s.color);
                glow.addColorStop(1, "rgba(0,0,0,0)");
                ctx.fillStyle = glow;
                ctx.beginPath(); ctx.arc(x, y, 40, 0, Math.PI*2); ctx.fill();

                // 核
                ctx.fillStyle = "#fff";
                ctx.beginPath(); ctx.arc(x, y, 5, 0, Math.PI*2); ctx.fill();

                // ラベル
                ctx.fillStyle = "#fff";
                ctx.font = "12px Consolas";
                ctx.textAlign = "right";
                ctx.fillText(s.label, x - 20, y + 4);
            });

            // 2. 脳/OSノードの描画（右側の受信源）
            const cx = width * 0.7 + (mouse.x - width/2)*0.02;
            const cy = height * 0.5 + (mouse.y - height/2)*0.02;
            
            // 脳のグロー
            const coreGlow = ctx.createRadialGradient(cx, cy, 0, cx, cy, 100);
            coreGlow.addColorStop(0, "rgba(0, 255, 255, 0.4)");
            coreGlow.addColorStop(1, "rgba(0,0,0,0)");
            ctx.fillStyle = coreGlow;
            ctx.beginPath(); ctx.arc(cx, cy, 100, 0, Math.PI*2); ctx.fill();
            
            // 脳のラベル
            ctx.fillStyle = "#00ffff";
            ctx.font = "bold 16px Consolas";
            ctx.textAlign = "center";
            ctx.fillText("OS / PROCESSING", cx, cy + 60);

            // 3. パーティクルの更新と描画
            ctx.globalCompositeOperation = 'lighter'; // 加算合成（光らせる）
            particles.forEach(p => {
                p.update();
                p.draw();
            });
            ctx.globalCompositeOperation = 'source-over'; // 元に戻す

            // 4. 接続ライン（うっすら）
            ctx.lineWidth = 0.5;
            SENSES.forEach(s => {
                const sx = width * s.x + (mouse.x - width/2)*0.02;
                const sy = height * s.y + (mouse.y - height/2)*0.02;
                
                const grad = ctx.createLinearGradient(sx, sy, cx, cy);
                grad.addColorStop(0, s.color);
                grad.addColorStop(1, "rgba(0,255,255,0.1)");
                
                ctx.strokeStyle = grad;
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(cx, cy);
                ctx.stroke();
            });

            requestAnimationFrame(loop);
        }

        // スタート
        init();

    </script>
</body>
</html>
