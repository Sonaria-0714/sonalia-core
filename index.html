<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>SONALIA CORE: DIAGNOSTIC</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }

        /* UIレイヤー */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }

        #hud-title {
            position: absolute; top: 30px; left: 30px;
            border-left: 4px solid #00ffff; padding-left: 20px;
            background: linear-gradient(90deg, rgba(0,20,30,0.8), transparent);
        }
        h1 { margin: 0; font-size: 32px; color: #fff; text-shadow: 0 0 15px #00ffff; letter-spacing: 2px; }
        p { margin: 5px 0 0; color: #00ffff; font-size: 14px; letter-spacing: 1px; font-family: monospace; }

        #hud-status {
            position: absolute; top: 30px; right: 30px;
            background: rgba(10,0,20,0.8); border: 1px solid #aa00ff;
            color: #dcb3ff; padding: 5px 15px; border-radius: 20px; font-size: 12px;
            box-shadow: 0 0 10px rgba(170,0,255,0.4);
        }

        #hud-flow {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: #88aaff; font-size: 16px; letter-spacing: 4px; font-family: monospace;
            text-shadow: 0 0 10px rgba(0,100,255,0.8);
        }

        /* 診断ログ（左下） */
        #debug-log {
            position: absolute; bottom: 10px; left: 10px; z-index: 100;
            color: #00ff00; font-family: monospace; font-size: 10px;
            background: rgba(0,0,0,0.7); padding: 5px; pointer-events: auto;
            max-height: 200px; overflow-y: auto; border: 1px solid #004400;
            width: 300px;
        }

        /* 詳細パネル */
        #panel {
            position: absolute; top: 0; right: 0; width: 380px; height: 100%;
            background: rgba(5, 8, 12, 0.95); border-left: 1px solid rgba(255,255,255,0.2);
            transform: translateX(100%); transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);
            color: #eee; display: flex; flex-direction: column; z-index: 20; pointer-events: auto;
            backdrop-filter: blur(10px);
        }
        #panel.active { transform: translateX(0); }
        .p-head { padding: 40px 30px; border-bottom: 1px solid rgba(255,255,255,0.1); background: linear-gradient(180deg, rgba(0,255,255,0.1), transparent); }
        .p-tag { font-size: 10px; padding: 3px 8px; border-radius: 2px; background: #00ffff; color: #000; font-weight: bold; }
        .p-title { font-size: 28px; margin: 15px 0 0; color: #fff; text-shadow: 0 0 10px currentColor; }
        .p-body { padding: 30px; overflow-y: auto; flex: 1; }
        .row { margin-bottom: 30px; }
        .label { font-size: 11px; color: #00ffff; border-bottom: 1px solid rgba(255,255,255,0.2); display: block; margin-bottom: 8px; }
        .text { font-size: 14px; line-height: 1.7; color: #ccc; }
        .thought { font-family: monospace; color: #fff; background: rgba(0,255,255,0.05); padding: 15px; border-left: 3px solid #00ffff; }
        .close-btn { position: absolute; top: 20px; right: 20px; font-size: 24px; cursor: pointer; color: #777; }
        .close-btn:hover { color: #fff; }

        /* ローディング */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.5s; cursor: pointer;
        }
        .load-text { font-size: 30px; color: #fff; font-weight: bold; text-shadow: 0 0 20px #00ffff; }
        .load-sub { color: #00ffff; font-family: monospace; margin-top: 10px; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="loader" onclick="forceStart()">
        <div class="load-text">SONALIA CORE</div>
        <div class="load-sub">INITIALIZING... (CLICK TO START)</div>
    </div>

    <div id="ui-layer">
        <div id="hud-title">
            <h1>思考回路マップ</h1>
            <p>4層OS × 内面DB × 8係数</p>
        </div>
        <div id="hud-status">Sonalia 4D View</div>
        <div id="hud-flow">現在（入力・意味付け） ▶▶▶ 未来（選択・行動）</div>
        <div id="debug-log">System Log:<br></div>
    </div>

    <div id="panel">
        <div class="close-btn" onclick="closePanel()">×</div>
        <div class="p-head">
            <span class="p-tag" id="p-tag">TAG</span>
            <h2 class="p-title" id="p-title">Title</h2>
        </div>
        <div class="p-body">
            <div class="row"><span class="label">DEFINITION</span><div class="text" id="p-desc">...</div></div>
            <div class="row"><span class="label">SYSTEM ROLE</span><div class="text" id="p-role">...</div></div>
            <div class="row"><span class="label">INTERNAL VOICE</span><div class="thought" id="p-thought">...</div></div>
        </div>
    </div>

    <script>
        // ログ出力関数
        function log(msg) {
            const el = document.getElementById('debug-log');
            const time = new Date().toLocaleTimeString();
            el.innerHTML += `[${time}] ${msg}<br>`;
            el.scrollTop = el.scrollHeight;
            console.log(msg);
        }

        // エラーハンドリング
        window.onerror = function(msg, url, line) {
            log(`<span style="color:red">ERROR: ${msg} (Line:${line})</span>`);
            // エラーが出ても強制的にローディングを消してみる
            document.getElementById('loader').style.display = 'none';
        };

        log("Script started.");

        // 変数定義
        let scene, camera, renderer, controls;
        let mainGroup, clock;
        const interactables = [];
        
        // データ
        const DATA = {
            LEFT: [
                { type:"OS(1層)", name:"生存OS", color:0x00FFFF, desc:"危険回避・安全確保。", role:"リスク管理", thought:"「危なくないか？」" },
                { type:"OS(1層)", name:"生活OS", color:0x00FF88, desc:"ルーティン維持・変化適応。", role:"習慣維持", thought:"「いつものパターン？」" },
                { type:"OS(2層)", name:"評価OS", color:0x0088FF, desc:"善悪・ルールの判定。", role:"善悪判断", thought:"「それは正しいか？」" },
                { type:"OS(2層)", name:"所属OS", color:0xFF8800, desc:"集団帰属・疎外感回避。", role:"集団帰属", thought:"「浮いてないか？」" },
                { type:"OS(3層)", name:"報酬OS", color:0xFFD700, desc:"損得・コスパ計算。", role:"損得勘定", thought:"「損しないか？」" },
                { type:"OS(3層)", name:"意味OS", color:0xAA00FF, desc:"意義・自己実現。", role:"意義探求", thought:"「どんな意味がある？」" },
                { type:"OS(4層)", name:"時間OS", color:0x00FFFF, desc:"過去経験・未来予測。", role:"時間参照", thought:"「将来どうなる？」" },
                { type:"OS(4層)", name:"協調OS", color:0xFF00AA, desc:"利害バランス調整。", role:"利害調整", thought:"「相手はどう思う？」" },
                { type:"DB", name:"欲求DB", color:0xFF4400, desc:"根源的渇望。", role:"Motivation", thought:"(Deep Desire)" },
                { type:"DB", name:"情動DB", color:0x0044FF, desc:"感情記憶。", role:"Emotion", thought:"(Flashback)" },
                { type:"DB", name:"価値観DB", color:0xFFCC00, desc:"信念・ルール。", role:"Belief", thought:"(Core Rules)" },
                { type:"DB", name:"無意識DB", color:0x888888, desc:"反射的クセ。", role:"Auto-Pilot", thought:"(Reflex)" }
            ],
            RIGHT: [
                { type:"係数", name:"IQ(論理)", color:0x00CCFF, desc:"情報構造化・論理力。", role:"Logic Engine", thought:"分析・分解" },
                { type:"係数", name:"EQ(感情)", color:0xFF6666, desc:"感情察知・共感力。", role:"Empathy", thought:"共感・配慮" },
                { type:"係数", name:"SQ(社会)", color:0xFFCC00, desc:"関係構築・適応力。", role:"Social Net", thought:"適応・交渉" },
                { type:"係数", name:"AQ(逆境)", color:0x888888, desc:"ストレス耐性。", role:"Resilience", thought:"耐久・忍耐" },
                { type:"係数", name:"CQ(創造)", color:0xAA00FF, desc:"好奇心・発想力。", role:"Innovator", thought:"発想・着眼" },
                { type:"係数", name:"HQ(人間)", color:0xFFFFFF, desc:"誠実さ・公平性。", role:"Ethical", thought:"誠実・信頼" },
                { type:"係数", name:"MQ(行動)", color:0xFF3300, desc:"実行スピード。", role:"Activator", thought:"即断・実行" },
                { type:"係数", name:"KQ(知識)", color:0x00FF88, desc:"知識活用力。", role:"Knowledge", thought:"応用・転用" }
            ]
        };

        // 初期化処理
        function init() {
            log("Init start...");
            
            if (typeof THREE === 'undefined') {
                log("FATAL: THREE is undefined.");
                return;
            }

            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020205, 0.0012);
            scene.background = new THREE.Color(0x020205);

            // Camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 3000);
            camera.position.set(0, 50, 450);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            log("Renderer created.");

            // Controls
            if(THREE.OrbitControls) {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.autoRotate = true;
                controls.autoRotateSpeed = 0.5;
            } else {
                log("OrbitControls missing. Skipping.");
            }

            // Group
            mainGroup = new THREE.Group();
            mainGroup.rotation.z = Math.PI / 16;
            scene.add(mainGroup);

            // Texture
            const glowTex = createGlowTex();

            // Objects
            createObjects(glowTex);

            // Clock
            clock = new THREE.Clock();

            // Start Animation
            animate();
            log("Animation started.");
            
            // Hide Loader
            setTimeout(forceStart, 1000);
        }

        // オブジェクト生成
        function createObjects(tex) {
            const nodes = [];

            // A. LEFT
            DATA.LEFT.forEach((d, i) => {
                const total = DATA.LEFT.length;
                const angle = (i / total) * Math.PI * 2;
                const r = 100 + Math.random() * 40;
                const x = -Math.abs(Math.cos(angle) * r * 1.5) - 30;
                const y = Math.sin(angle) * r;
                const z = (Math.random()-0.5) * 80;
                const pos = new THREE.Vector3(x, y, z);

                const mesh = new THREE.Mesh(new THREE.SphereGeometry(4, 16, 16), new THREE.MeshBasicMaterial({ color: d.color, wireframe: true }));
                mesh.position.copy(pos);
                mesh.userData = { data: d, color: d.color };
                
                const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, color: d.color, blending: THREE.AdditiveBlending }));
                spr.scale.set(40,40,1);
                mesh.add(spr);

                mainGroup.add(mesh);
                interactables.push(mesh);
                nodes.push({ pos: pos, color: new THREE.Color(d.color), group: 'left' });
            });

            // B. RIGHT
            DATA.RIGHT.forEach((d, i) => {
                const total = DATA.RIGHT.length;
                const angle = (i / total) * Math.PI * 2;
                const r = 120 + Math.random() * 40;
                const x = Math.abs(Math.cos(angle) * r * 1.8) + 50;
                const y = Math.sin(angle) * r;
                const z = (Math.random()-0.5) * 80;
                const pos = new THREE.Vector3(x, y, z);

                const mesh = new THREE.Mesh(new THREE.BoxGeometry(6,6,6), new THREE.MeshBasicMaterial({ color: d.color, wireframe: true }));
                mesh.position.copy(pos);
                mesh.userData = { data: d, color: d.color };

                const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, color: d.color, blending: THREE.AdditiveBlending }));
                spr.scale.set(50,50,1);
                mesh.add(spr);

                mainGroup.add(mesh);
                interactables.push(mesh);
                nodes.push({ pos: pos, color: new THREE.Color(d.color), group: 'right' });
            });

            // C. LINES
            const lineGeo = new THREE.Geometry();
            const lineColors = [];
            nodes.forEach((n1, i) => {
                nodes.forEach((n2, j) => {
                    if(i>=j) return;
                    const dist = n1.pos.distanceTo(n2.pos);
                    if(dist < 100) {
                        lineGeo.vertices.push(n1.pos);
                        lineGeo.vertices.push(n2.pos);
                        const c = n1.color.clone().lerp(n2.color, 0.5);
                        lineColors.push(c);
                        lineColors.push(c);
                    }
                });
            });
            lineGeo.colors = lineColors;
            const lineMat = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors, transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending });
            const network = new THREE.LineSegments(lineGeo, lineMat);
            mainGroup.add(network);
        }

        function createGlowTex() {
            const c = document.createElement('canvas'); c.width=32; c.height=32;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(16,16,0, 16,16,16);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(0.4, 'rgba(255,255,255,0.2)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(c);
        }

        // アニメーションループ
        function animate() {
            requestAnimationFrame(animate);
            if(TWEEN) TWEEN.update();
            if(controls) controls.update();
            
            const time = clock.getElapsedTime();
            mainGroup.rotation.y = Math.sin(time*0.1) * 0.1;
            
            renderer.render(scene, camera);
        }

        // インタラクション
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('mousedown', (e) => {
            if(e.target.closest('#panel') || e.target.closest('#loader')) return;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(interactables);
            if(hits.length > 0) {
                const ud = hits[0].object.userData;
                showPanel(ud.data, ud.color);
                log("Clicked: " + ud.data.name);
            } else {
                closePanel();
            }
        });

        function showPanel(d, color) {
            document.getElementById('p-tag').innerText = d.type;
            document.getElementById('p-tag').style.background = '#'+new THREE.Color(color).getHexString();
            document.getElementById('p-title').innerText = d.name;
            document.getElementById('p-title').style.color = '#'+new THREE.Color(color).getHexString();
            document.getElementById('p-desc').innerText = d.desc;
            document.getElementById('p-role').innerText = d.role;
            document.getElementById('p-thought').innerText = d.thought;
            document.getElementById('panel').classList.add('active');
        }
        function closePanel() {
            document.getElementById('panel').classList.remove('active');
        }
        window.closePanel = closePanel;

        function forceStart() {
            const l = document.getElementById('loader');
            l.style.opacity = 0;
            setTimeout(() => { l.style.display = 'none'; }, 800);
            log("Force started.");
        }
        window.forceStart = forceStart;

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 実行開始
        window.onload = init;

    </script>
</body>
</html>
