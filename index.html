<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sonalia System: Neural Logic</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Consolas', sans-serif; }
        canvas { display: block; }

        /* ローディング画面 */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 1s;
        }
        .loader-text { color: #00ffff; font-size: 14px; letter-spacing: 3px; animation: blink 1s infinite; margin-bottom: 20px; }
        @keyframes blink { 50% { opacity: 0.5; } }
        
        /* エラーログ */
        #error-display { color: #ff3333; font-size: 12px; border: 1px solid #ff3333; padding: 10px; display: none; }

        /* UI */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #hud-left { position: absolute; top: 20px; left: 20px; }
        .hud-line { color: rgba(0, 255, 255, 0.7); font-size: 12px; margin-bottom: 5px; text-shadow: 0 0 5px rgba(0,255,255,0.5); }
        
        #logic-flow {
            position: absolute; bottom: 40px; width: 100%; text-align: center;
            color: #fff; font-size: 16px; text-shadow: 0 0 10px currentColor; font-family: monospace;
        }

        /* パネル */
        #panel {
            position: absolute; top: 0; right: 0; width: 350px; height: 100%;
            background: rgba(10, 15, 20, 0.9); border-left: 1px solid #333;
            transform: translateX(100%); transition: 0.3s; pointer-events: auto;
            color: #eee; padding: 30px; box-sizing: border-box; backdrop-filter: blur(10px);
        }
        #panel.active { transform: translateX(0); }
        h2 { color: #00ffff; border-bottom: 1px solid #444; padding-bottom: 10px; margin-top: 0; }
        .close-btn { position: absolute; top: 10px; right: 20px; cursor: pointer; font-size: 24px; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loader">
        <div class="loader-text">INITIALIZING NEURAL NETWORK...</div>
        <div id="error-display"></div>
    </div>

    <div id="ui-layer">
        <div id="hud-left">
            <div class="hud-line">SONALIA CORE: ONLINE</div>
            <div class="hud-line">ARCHITECTURE: NEURAL MESH v4.0</div>
        </div>
        <div id="logic-flow">WAITING...</div>
    </div>

    <div id="panel">
        <div class="close-btn" id="p-close">×</div>
        <h2 id="p-title">TITLE</h2>
        <div style="font-size:10px; background:#fff; color:#000; display:inline-block; padding:2px 5px; margin-bottom:15px;" id="p-type">TYPE</div>
        <p id="p-desc" style="font-size:13px; line-height:1.6;">Description</p>
    </div>

    <script type="module">
        // 修正点: ここで OrbitControls を明示的にインポートすることでエラーを回避
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // エラーハンドリング
        window.onerror = function(msg) {
            const el = document.getElementById('error-display');
            el.style.display = 'block';
            el.innerText = "Error: " + msg;
        };

        // ==========================================
        // DATA
        // ==========================================
        const DATA = {
            OS: [
                { id: "SURVIVAL", name: "生存OS", color: 0xFF3333, desc: "危険回避・安全確保を最優先するOS。" },
                { id: "LIFE",     name: "生活OS", color: 0x33FF33, desc: "ルーティン維持・新規探索を判断するOS。" },
                { id: "EVAL",     name: "評価OS", color: 0x3388FF, desc: "善悪・正誤・ルールを判定するOS。" },
                { id: "BELONG",   name: "所属OS", color: 0xFF8833, desc: "集団の内外・仲間意識を判定するOS。" },
                { id: "REWARD",   name: "報酬OS", color: 0xFFD700, desc: "損得・コスパ・メリットを計算するOS。" },
                { id: "MEANING",  name: "意味OS", color: 0x9933FF, desc: "意義・自己実現・物語性を重視するOS。" },
                { id: "TIME",     name: "時間OS", color: 0x00FFFF, desc: "過去の経験か、未来の予測かを判断するOS。" },
                { id: "HARMONY",  name: "協調OS", color: 0xFF66AA, desc: "自分と他人の利害バランスを調整するOS。" }
            ],
            COEF: [
                { id: "IQ", color: 0x00CCFF, desc: "論理・分析係数。" }, { id: "EQ", color: 0xFF6666, desc: "感情リテラシー係数。" },
                { id: "SQ", color: 0xFFCC00, desc: "社会・対人係数。" }, { id: "AQ", color: 0x888888, desc: "逆境耐性係数。" },
                { id: "CQ", color: 0xAA00FF, desc: "好奇・創造係数。" }, { id: "HQ", color: 0xFFFFFF, desc: "人間力・倫理係数。" },
                { id: "MQ", color: 0xFF3300, desc: "行動力係数。" }, { id: "KQ", color: 0x00FF88, desc: "知識活用係数。" }
            ],
            DB: [
                { id:"DESIRE", name: "欲求DB", color: 0xFF5500, pos: [-90, 60, -60], desc: "根源的な欲求の記憶。" },
                { id:"EMOTION", name: "情動DB", color: 0x0055FF, pos: [90, 60, -60], desc: "快・不快の感情記憶。" },
                { id:"VALUE", name: "価値観DB", color: 0xFFD700, pos: [-90, -60, -60], desc: "信念・ルールのログ。" },
                { id:"IMPLICIT", name: "無意識DB", color: 0x666666, pos: [90, -60, -60], desc: "習慣や反射行動のログ。" }
            ]
        };

        // ==========================================
        // SCENE
        // ==========================================
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
        camera.position.set(0, 40, 260);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // 修正点: THREE.OrbitControls ではなく、インポートした OrbitControls を使う
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // Glow Texture
        function createGlowTexture() {
            const c = document.createElement('canvas'); c.width=64; c.height=64;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(32,32,0, 32,32,32);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(0.4, 'rgba(255,255,255,0.2)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g; ctx.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(c);
        }
        const glowTex = createGlowTexture();
        const interactables = [];
        const allNodes = [];

        const mainGroup = new THREE.Group();
        scene.add(mainGroup);

        // ==========================================
        // OBJECTS
        // ==========================================

        // A. OS CORE (Neural Brain)
        const osGroup = new THREE.Group();
        mainGroup.add(osGroup);
        // Wireframe Brain
        const coreGeo = new THREE.IcosahedronGeometry(15, 2);
        const posAttr = coreGeo.attributes.position;
        // Organic Noise
        for(let i=0; i<posAttr.count; i++){
            const x = posAttr.getX(i);
            const y = posAttr.getY(i);
            const z = posAttr.getZ(i);
            const noise = 1 + Math.random()*0.1;
            posAttr.setXYZ(i, x*noise, y*noise, z*noise);
        }
        const coreMat = new THREE.MeshBasicMaterial({ color: 0x0088ff, wireframe: true, transparent: true, opacity: 0.15 });
        const core = new THREE.Mesh(coreGeo, coreMat);
        osGroup.add(core);

        DATA.OS.forEach((d, i) => {
            const phi = Math.acos( -1 + ( 2 * i ) / 8 );
            const theta = Math.sqrt( 8 * Math.PI ) * phi;
            const r = 20;
            const x = r * Math.cos(theta) * Math.sin(phi);
            const y = r * Math.sin(theta) * Math.sin(phi);
            const z = r * Math.cos(phi);
            const pos = new THREE.Vector3(x, y, z);

            const mesh = new THREE.Mesh(new THREE.SphereGeometry(2), new THREE.MeshBasicMaterial({ color: d.color }));
            mesh.position.copy(pos);
            mesh.userData = { type: 'OS', data: d };
            
            const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: glowTex, color: d.color, blending: THREE.AdditiveBlending }));
            spr.scale.set(25,25,1);
            mesh.add(spr);

            osGroup.add(mesh);
            interactables.push(mesh);
            allNodes.push({ pos: pos, color: new THREE.Color(d.color), group:'OS' });
        });

        // B. COEFFICIENTS
        const coefGroup = new THREE.Group();
        mainGroup.add(coefGroup);
        const coefMeshes = [];

        DATA.COEF.forEach((d, i) => {
            const angle = (i / 8) * Math.PI * 2;
            const rad = 70;
            const x = Math.cos(angle) * rad;
            const z = Math.sin(angle) * rad;
            const pos = new THREE.Vector3(x, 0, z);

            const mesh = new THREE.Mesh(new THREE.BoxGeometry(4,4,4), new THREE.MeshBasicMaterial({ color: d.color, wireframe: true }));
            mesh.position.copy(pos);
            mesh.userData = { type: 'COEF', data: d };

            const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: glowTex, color: d.color, blending: THREE.AdditiveBlending }));
            spr.scale.set(35,35,1);
            mesh.add(spr);

            coefGroup.add(mesh);
            interactables.push(mesh);
            coefMeshes.push(mesh);
            allNodes.push({ pos: pos, color: new THREE.Color(d.color), group:'COEF' });
        });

        // C. DB CLOUDS
        const dbGroup = new THREE.Group();
        mainGroup.add(dbGroup);

        DATA.DB.forEach(d => {
            const count = 120;
            const pPos = [];
            const pCol = [];
            const baseCol = new THREE.Color(d.color);
            
            for(let i=0; i<count; i++) {
                const spread = 45;
                const v = new THREE.Vector3(
                    d.pos[0] + (Math.random()-0.5)*spread,
                    d.pos[1] + (Math.random()-0.5)*spread,
                    d.pos[2] + (Math.random()-0.5)*spread
                );
                pPos.push(v.x, v.y, v.z);
                pCol.push(baseCol.r, baseCol.g, baseCol.b);

                // 一部を接続用に登録
                if(Math.random()>0.9) allNodes.push({ pos: v, color: baseCol, group:'DB' });
            }
            
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pPos, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(pCol, 3));
            const mat = new THREE.PointsMaterial({ size: 2, map: glowTex, vertexColors: true, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending, depthWrite: false });
            const pts = new THREE.Points(geo, mat);
            dbGroup.add(pts);

            // Hitbox
            const box = new THREE.Mesh(new THREE.BoxGeometry(50,50,50), new THREE.MeshBasicMaterial({visible:false}));
            box.position.set(d.pos[0], d.pos[1], d.pos[2]);
            box.userData = { type: 'DB', data: d };
            interactables.push(box);
        });

        // D. NEURAL SYNAPSES (Lines)
        const linePos = [];
        const lineColors = [];
        
        for(let i=0; i<allNodes.length; i++) {
            for(let j=i+1; j<allNodes.length; j++) {
                const n1 = allNodes[i];
                const n2 = allNodes[j];
                const dist = n1.pos.distanceTo(n2.pos);
                
                // 距離による接続判定 + グループまたぎを優先
                if(dist < 85 && (dist < 30 || n1.group !== n2.group)) {
                    linePos.push(n1.pos.x, n1.pos.y, n1.pos.z);
                    linePos.push(n2.pos.x, n2.pos.y, n2.pos.z);
                    lineColors.push(n1.color.r, n1.color.g, n1.color.b);
                    lineColors.push(n2.color.r, n2.color.g, n2.color.b);
                }
            }
        }
        
        const lineGeo = new THREE.BufferGeometry();
        lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePos, 3));
        lineGeo.setAttribute('color', new THREE.Float32BufferAttribute(lineColors, 3));
        const lineMat = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending });
        const synapses = new THREE.LineSegments(lineGeo, lineMat);
        mainGroup.add(synapses);

        // E. LOGIC PULSE
        const pulse = new THREE.Mesh(new THREE.SphereGeometry(2), new THREE.MeshBasicMaterial({color:0xffffff}));
        const pulseSpr = new THREE.Sprite(new THREE.SpriteMaterial({map: glowTex, color: 0xffffff, blending: THREE.AdditiveBlending}));
        pulseSpr.scale.set(20,20,1);
        pulse.add(pulseSpr);
        scene.add(pulse);

        // ==========================================
        // ANIMATION
        // ==========================================
        const clock = new THREE.Clock();
        const flowText = document.getElementById('logic-flow');
        
        // Remove Loader
        setTimeout(function(){
            const l = document.getElementById('loader');
            if(l) { l.style.opacity = 0; setTimeout(()=>l.style.display='none', 500); }
        }, 1500);

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            if(controls) controls.update();

            // Organic Motion
            osGroup.rotation.y = Math.sin(time*0.2)*0.2;
            const beat = 1 + Math.sin(time*2.5)*0.02;
            osGroup.scale.set(beat, beat, beat);
            synapses.scale.set(beat, beat, beat); // Lines move with brain

            coefGroup.rotation.y = time * -0.15;
            coefMeshes.forEach((m,i) => {
                m.rotation.x += 0.02; 
                m.position.y = Math.sin(time + i)*5;
            });
            synapses.rotation.y = Math.sin(time*0.1)*0.05;

            // Logic Loop
            const t = time % 6.0;
            let target = new THREE.Vector3();
            let col = 0xffffff;
            let txt = "";

            if (t < 1.5) {
                let p = t/1.5;
                target.set(0, 160*(1-p), 120*(1-p));
                txt = ">>> INPUT SIGNAL >>>";
            } else if (t < 3.5) {
                let p = (t-1.5)/2.0;
                let db = new THREE.Vector3(90, 60, -60);
                if(p<0.5) target.lerpVectors(new THREE.Vector3(), db, p*2);
                else target.lerpVectors(db, new THREE.Vector3(), (p-0.5)*2);
                col = 0x0055FF;
                txt = "::: NEURAL MEMORY ACCESS :::";
            } else if (t < 4.5) {
                let p = (t-3.5);
                target.lerpVectors(new THREE.Vector3(), new THREE.Vector3(70,0,0), p);
                col = 0x00CCFF;
                txt = "/// PROCESSING VECTOR ///";
            } else {
                let p = (t-4.5)/1.5;
                target.lerpVectors(new THREE.Vector3(70,0,0), new THREE.Vector3(250,0,0), p);
                col = 0xFF3300;
                txt = "!!! ACTION OUTPUT !!!";
            }

            pulse.position.copy(target);
            pulse.material.color.setHex(col);
            pulseSpr.material.color.setHex(col);
            if(flowText) {
                flowText.innerText = txt;
                flowText.style.color = '#' + col.toString(16).padStart(6,'0');
            }

            renderer.render(scene, camera);
        }
        animate();

        // Interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        window.addEventListener('mousedown', function(e){
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(interactables);
            if(hits.length > 0) {
                showPanel(hits[0].object.userData);
            } else {
                hidePanel();
            }
        });

        const panel = document.getElementById('panel');
        const pClose = document.getElementById('p-close');
        if(pClose) pClose.addEventListener('click', hidePanel);

        function showPanel(ud) {
            document.getElementById('p-title').innerText = ud.data.name || ud.data.id;
            document.getElementById('p-desc').innerText = ud.data.desc;
            document.getElementById('p-type').innerText = ud.type;
            panel.classList.add('active');
        }
        function hidePanel() {
            panel.classList.remove('active');
        }

        window.addEventListener('resize', function(){
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
