<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SONALIA: NEURAL CORE</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }

        /* --- エラー表示エリア (解決確認用) --- */
        #error-console {
            position: fixed; bottom: 0; left: 0; width: 100%; background: rgba(50,0,0,0.9); 
            color: #ffaaaa; font-family: monospace; font-size: 12px; padding: 5px; 
            z-index: 99999; display: none;
        }

        /* --- ローディング画面 --- */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: #000; z-index: 9999; cursor: pointer;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.8s;
        }
        .logo { 
            font-size: 40px; font-weight: bold; color: #fff; letter-spacing: 5px; 
            text-shadow: 0 0 20px #00ffff; margin-bottom: 20px;
        }
        .loading-text { color: #00ffff; font-family: monospace; font-size: 14px; animation: blink 1s infinite; }
        .tap-hint { margin-top: 30px; border: 1px solid #00ffff; color: #00ffff; padding: 10px 20px; border-radius: 30px; font-size: 12px; }
        
        @keyframes blink { 50% { opacity: 0.5; } }

        /* --- UIレイヤー --- */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        #hud-title {
            position: absolute; top: 30px; left: 30px; pointer-events: auto;
            border-left: 4px solid #00ffff; padding-left: 15px;
            background: linear-gradient(90deg, rgba(0,20,30,0.8), transparent);
        }
        h1 { margin: 0; font-size: 28px; color: #fff; text-shadow: 0 0 10px #00ffff; letter-spacing: 2px; }
        p { margin: 5px 0 0; color: #00ffff; font-size: 12px; font-family: monospace; }

        #hud-footer {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: #88aaff; font-size: 14px; letter-spacing: 3px; font-family: monospace;
            text-shadow: 0 0 10px rgba(0,100,255,0.5);
        }

        /* --- 詳細パネル --- */
        #panel {
            position: absolute; top: 0; right: 0; width: 350px; height: 100%;
            background: rgba(10, 15, 20, 0.95); border-left: 1px solid #333;
            transform: translateX(100%); transition: transform 0.3s;
            color: #eee; display: flex; flex-direction: column; z-index: 20; pointer-events: auto;
            box-shadow: -20px 0 50px rgba(0,0,0,0.8);
        }
        #panel.active { transform: translateX(0); }
        .p-head { padding: 30px; border-bottom: 1px solid #333; background: linear-gradient(180deg, rgba(0,255,255,0.1), transparent); }
        .p-tag { font-size: 10px; padding: 2px 8px; border-radius: 2px; background: #00ffff; color: #000; font-weight: bold; }
        .p-title { font-size: 24px; margin: 15px 0 0; color: #fff; }
        .p-body { padding: 30px; overflow-y: auto; flex: 1; }
        .row { margin-bottom: 20px; }
        .label { font-size: 10px; color: #00ffff; display: block; margin-bottom: 5px; border-bottom: 1px solid #333; }
        .text { font-size: 13px; line-height: 1.6; color: #ccc; }
        .close { position: absolute; top: 20px; right: 20px; font-size: 24px; cursor: pointer; color: #fff; }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r120/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.120.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="error-console"></div>

    <div id="loader" onclick="startApp()">
        <div class="logo">SONALIA</div>
        <div class="loading-text">LOADING NEURAL MAP...</div>
        <div class="tap-hint">CLICK TO START</div>
    </div>

    <div id="ui-layer">
        <div id="hud-title">
            <h1>思考回路マップ</h1>
            <p>4層OS × 内面DB × 8係数</p>
        </div>
        <div id="hud-footer">
            現在（入力・意味付け） ▶▶▶ 未来（選択・行動）
        </div>
    </div>

    <div id="panel">
        <div class="close" onclick="closePanel()">×</div>
        <div class="p-head">
            <span class="p-tag" id="p-tag">TAG</span>
            <h2 class="p-title" id="p-title">Title</h2>
        </div>
        <div class="p-body">
            <div class="row"><span class="label">DEFINITION</span><div class="text" id="p-desc">...</div></div>
            <div class="row"><span class="label">SYSTEM ROLE</span><div class="text" id="p-role">...</div></div>
            <div class="row"><span class="label">INTERNAL VOICE</span><div class="text" id="p-thought" style="color:#fff; font-family:monospace;">...</div></div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        // エラーハンドリング
        window.onerror = function(msg, url, line) {
            const el = document.getElementById('error-console');
            if(el) {
                el.style.display = 'block';
                el.innerHTML = "Error: " + msg + " (Line: " + line + ")";
            }
            return false;
        };

        // --- データ定義 ---
        const DATA = {
            LEFT: [
                { id:"OS1", type:"OS(1層)", name:"生存OS", color:0x00FFFF, desc:"危険回避・安全確保。", role:"リスク管理", thought:"「危なくないか？」" },
                { id:"OS2", type:"OS(1層)", name:"生活OS", color:0x00FF88, desc:"ルーティン維持・変化適応。", role:"習慣維持", thought:"「いつものパターン？」" },
                { id:"OS3", type:"OS(2層)", name:"評価OS", color:0x0088FF, desc:"善悪・ルールの判定。", role:"善悪判断", thought:"「それは正しいか？」" },
                { id:"OS4", type:"OS(2層)", name:"所属OS", color:0xFF8800, desc:"集団帰属・疎外感回避。", role:"集団帰属", thought:"「浮いてないか？」" },
                { id:"OS5", type:"OS(3層)", name:"報酬OS", color:0xFFD700, desc:"損得・コスパ計算。", role:"損得勘定", thought:"「損しないか？」" },
                { id:"OS6", type:"OS(3層)", name:"意味OS", color:0xAA00FF, desc:"意義・自己実現。", role:"意義探求", thought:"「どんな意味がある？」" },
                { id:"OS7", type:"OS(4層)", name:"時間OS", color:0x00FFFF, desc:"過去経験・未来予測。", role:"時間参照", thought:"「将来どうなる？」" },
                { id:"OS8", type:"OS(4層)", name:"協調OS", color:0xFF00AA, desc:"利害バランス調整。", role:"利害調整", thought:"「相手はどう思う？」" },
                { id:"DB1", type:"DB", name:"欲求DB", color:0xFF4400, desc:"根源的渇望。", role:"Motivation", thought:"(Deep Desire)" },
                { id:"DB2", type:"DB", name:"情動DB", color:0x0044FF, desc:"感情記憶。", role:"Emotion", thought:"(Flashback)" },
                { id:"DB3", type:"DB", name:"価値観DB", color:0xFFCC00, desc:"信念・ルール。", role:"Belief", thought:"(Core Rules)" },
                { id:"DB4", type:"DB", name:"無意識DB", color:0x888888, desc:"反射的クセ。", role:"Auto-Pilot", thought:"(Reflex)" }
            ],
            RIGHT: [
                { id:"IQ", type:"係数", name:"IQ(論理)", color:0x00CCFF, desc:"情報構造化・論理力。", role:"Logic Engine", thought:"分析・分解" },
                { id:"EQ", type:"係数", name:"EQ(感情)", color:0xFF6666, desc:"感情察知・共感力。", role:"Empathy", thought:"共感・配慮" },
                { id:"SQ", type:"係数", name:"SQ(社会)", color:0xFFCC00, desc:"関係構築・適応力。", role:"Social Net", thought:"適応・交渉" },
                { id:"AQ", type:"係数", name:"AQ(逆境)", color:0x888888, desc:"ストレス耐性。", role:"Resilience", thought:"耐久・忍耐" },
                { id:"CQ", type:"係数", name:"CQ(創造)", color:0xAA00FF, desc:"好奇心・発想力。", role:"Innovator", thought:"発想・着眼" },
                { id:"HQ", type:"係数", name:"HQ(人間)", color:0xFFFFFF, desc:"誠実さ・公平性。", role:"Ethical", thought:"誠実・信頼" },
                { id:"MQ", type:"係数", name:"MQ(行動)", color:0xFF3300, desc:"実行スピード。", role:"Activator", thought:"即断・実行" },
                { id:"KQ", type:"係数", name:"KQ(知識)", color:0x00FF88, desc:"知識活用力。", role:"Knowledge", thought:"応用・転用" }
            ]
        };

        // --- メイン処理 ---
        let scene, camera, renderer, controls;
        const interactables = [];
        const clock = new THREE.Clock();
        
        let mainGroup, networkGeo;

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020205, 0.0015);
            scene.background = new THREE.Color(0x020205);

            // Camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 3000);
            camera.position.set(0, 50, 450);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById('canvas') });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            // Group
            mainGroup = new THREE.Group();
            mainGroup.rotation.z = Math.PI / 16;
            scene.add(mainGroup);

            // Texture
            const glowTex = createGlowTex();

            // Objects
            createObjects(glowTex);

            // Start Animation
            animate();
            
            // Hide Loader
            setTimeout(startApp, 1500);
        }

        function createObjects(tex) {
            const nodes = [];

            // A. LEFT
            DATA.LEFT.forEach((d, i) => {
                const total = DATA.LEFT.length;
                const angle = (i / total) * Math.PI * 2;
                const r = 100 + Math.random() * 40;
                const x = -Math.abs(Math.cos(angle) * r * 1.5) - 30;
                const y = Math.sin(angle) * r;
                const z = (Math.random()-0.5) * 80;
                const pos = new THREE.Vector3(x, y, z);

                const mesh = new THREE.Mesh(new THREE.SphereGeometry(4, 16, 16), new THREE.MeshBasicMaterial({ color: d.color, wireframe: true }));
                mesh.position.copy(pos);
                mesh.userData = { data: d, color: d.color };
                
                const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, color: d.color, blending: THREE.AdditiveBlending }));
                spr.scale.set(40,40,1);
                mesh.add(spr);

                mainGroup.add(mesh);
                interactables.push(mesh);
                nodes.push({ pos: pos, color: new THREE.Color(d.color), group: 'left' });
            });

            // B. RIGHT
            DATA.RIGHT.forEach((d, i) => {
                const total = DATA.RIGHT.length;
                const angle = (i / total) * Math.PI * 2;
                const r = 120 + Math.random() * 40;
                const x = Math.abs(Math.cos(angle) * r * 1.8) + 50;
                const y = Math.sin(angle) * r;
                const z = (Math.random()-0.5) * 80;
                const pos = new THREE.Vector3(x, y, z);

                const mesh = new THREE.Mesh(new THREE.BoxGeometry(6,6,6), new THREE.MeshBasicMaterial({ color: d.color, wireframe: true }));
                mesh.position.copy(pos);
                mesh.userData = { data: d, color: d.color };

                const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, color: d.color, blending: THREE.AdditiveBlending }));
                spr.scale.set(50,50,1);
                mesh.add(spr);

                mainGroup.add(mesh);
                interactables.push(mesh);
                nodes.push({ pos: pos, color: new THREE.Color(d.color), group: 'right' });
            });

            // C. LINES (Using THREE.Geometry - This works in r120!)
            const lineGeo = new THREE.Geometry();
            
            nodes.forEach((n1, i) => {
                nodes.forEach((n2, j) => {
                    if(i>=j) return;
                    const dist = n1.pos.distanceTo(n2.pos);
                    if(dist < 100) {
                        lineGeo.vertices.push(n1.pos);
                        lineGeo.vertices.push(n2.pos);
                        const c = n1.color.clone().lerp(n2.color, 0.5);
                        lineGeo.colors.push(c);
                        lineGeo.colors.push(c);
                    }
                });
            });
            const lineMat = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors, transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending });
            const network = new THREE.LineSegments(lineGeo, lineMat);
            mainGroup.add(network);
        }

        function createGlowTex() {
            const c = document.createElement('canvas'); c.width=32; c.height=32;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(16,16,0, 16,16,16);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(0.4, 'rgba(255,255,255,0.2)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(c);
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            controls.update();
            const time = clock.getElapsedTime();
            mainGroup.rotation.y = Math.sin(time*0.1) * 0.1;
            renderer.render(scene, camera);
        }

        // Interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('mousedown', (e) => {
            if(e.target.closest('#panel') || e.target.closest('#loader')) return;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(interactables);
            if(hits.length > 0) {
                const ud = hits[0].object.userData;
                showPanel(ud.data, ud.color);
            } else {
                closePanel();
            }
        });

        function showPanel(d, color) {
            document.getElementById('p-tag').innerText = d.type;
            document.getElementById('p-tag').style.background = '#'+new THREE.Color(color).getHexString();
            document.getElementById('p-title').innerText = d.name;
            document.getElementById('p-title').style.color = '#'+new THREE.Color(color).getHexString();
            document.getElementById('p-desc').innerText = d.desc;
            document.getElementById('p-role').innerText = d.role;
            document.getElementById('p-thought').innerText = d.thought;
            document.getElementById('panel').classList.add('active');
        }
        function closePanel() {
            document.getElementById('panel').classList.remove('active');
        }
        window.closePanel = closePanel;

        function startApp() {
            const l = document.getElementById('loader');
            l.style.opacity = 0;
            setTimeout(() => { l.style.display = 'none'; }, 800);
        }
        window.startApp = startApp;

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 実行開始
        window.onload = init;

    </script>
</body>
</html>
