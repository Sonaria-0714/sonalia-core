<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sonalia System: Neural Safe</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Consolas', sans-serif; }
        canvas { display: block; }

        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.5s;
        }
        .loader-text { color: #00ffff; font-size: 14px; letter-spacing: 3px; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }
        
        #debug-log {
            color: red; font-size: 12px; margin-top: 20px; text-align: center; display: none; border: 1px solid red; padding: 10px;
        }

        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #hud-left { position: absolute; top: 20px; left: 20px; }
        .hud-line { color: rgba(0, 255, 255, 0.7); font-size: 12px; margin-bottom: 5px; text-shadow: 0 0 5px rgba(0,255,255,0.5); }
        
        #logic-flow {
            position: absolute; bottom: 40px; width: 100%; text-align: center;
            color: #fff; font-size: 16px; text-shadow: 0 0 10px currentColor; font-family: monospace;
        }

        #panel {
            position: absolute; top: 0; right: 0; width: 350px; height: 100%;
            background: rgba(10, 15, 20, 0.95); border-left: 1px solid #333;
            transform: translateX(100%); transition: 0.3s; pointer-events: auto;
            color: #eee; padding: 30px; box-sizing: border-box;
        }
        #panel.active { transform: translateX(0); }
        h2 { color: #00ffff; border-bottom: 1px solid #444; padding-bottom: 10px; }
        .close-btn { position: absolute; top: 10px; right: 20px; cursor: pointer; font-size: 24px; }
    </style>

    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="loader">
        <div class="loader-text">INITIALIZING NEURAL FABRIC...</div>
        <div id="debug-log"></div>
    </div>

    <div id="ui-layer">
        <div id="hud-left">
            <div class="hud-line">SONALIA CORE: ONLINE</div>
            <div class="hud-line">ARCHITECTURE: NEURAL MESH</div>
        </div>
        <div id="logic-flow">WAITING...</div>
    </div>

    <div id="panel">
        <div class="close-btn" onclick="document.getElementById('panel').classList.remove('active')">×</div>
        <h2 id="p-title">TITLE</h2>
        <div style="font-size:10px; background:#fff; color:#000; display:inline-block; padding:2px 5px; margin-bottom:15px;" id="p-type">TYPE</div>
        <p id="p-desc" style="font-size:13px; line-height:1.6;">Description</p>
    </div>

    <script>
        // エラー捕捉
        window.onerror = function(msg, url, line) {
            const d = document.getElementById('debug-log');
            d.style.display = 'block';
            d.innerHTML += "Error: " + msg + "<br>";
        };

        // ライブラリチェック
        if (typeof THREE === 'undefined') {
            throw new Error("Three.js not loaded.");
        }

        // ==========================================
        // DATA
        // ==========================================
        const DATA = {
            OS: [
                { id: "SURVIVAL", name: "生存OS", color: 0xFF3333, desc: "危険回避・安全確保を最優先するOS。" },
                { id: "LIFE",     name: "生活OS", color: 0x33FF33, desc: "ルーティン維持・新規探索を判断するOS。" },
                { id: "EVAL",     name: "評価OS", color: 0x3388FF, desc: "善悪・正誤・ルールを判定するOS。" },
                { id: "BELONG",   name: "所属OS", color: 0xFF8833, desc: "集団の内外・仲間意識を判定するOS。" },
                { id: "REWARD",   name: "報酬OS", color: 0xFFD700, desc: "損得・コスパ・メリットを計算するOS。" },
                { id: "MEANING",  name: "意味OS", color: 0x9933FF, desc: "意義・自己実現・物語性を重視するOS。" },
                { id: "TIME",     name: "時間OS", color: 0x00FFFF, desc: "過去の経験か、未来の予測かを判断するOS。" },
                { id: "HARMONY",  name: "協調OS", color: 0xFF66AA, desc: "自分と他人の利害バランスを調整するOS。" }
            ],
            COEF: [
                { id: "IQ", color: 0x00CCFF, desc: "論理・分析係数。" }, { id: "EQ", color: 0xFF6666, desc: "感情リテラシー係数。" },
                { id: "SQ", color: 0xFFCC00, desc: "社会・対人係数。" }, { id: "AQ", color: 0x888888, desc: "逆境耐性係数。" },
                { id: "CQ", color: 0xAA00FF, desc: "好奇・創造係数。" }, { id: "HQ", color: 0xFFFFFF, desc: "人間力・倫理係数。" },
                { id: "MQ", color: 0xFF3300, desc: "行動力係数。" }, { id: "KQ", color: 0x00FF88, desc: "知識活用係数。" }
            ],
            DB: [
                { id:"DESIRE", name: "欲求DB", color: 0xFF5500, pos: [-90, 60, -60], desc: "根源的な欲求の記憶。" },
                { id:"EMOTION", name: "情動DB", color: 0x0055FF, pos: [90, 60, -60], desc: "快・不快の感情記憶。" },
                { id:"VALUE", name: "価値観DB", color: 0xFFD700, pos: [-90, -60, -60], desc: "信念・ルールのログ。" },
                { id:"IMPLICIT", name: "無意識DB", color: 0x666666, pos: [90, -60, -60], desc: "習慣や反射行動のログ。" }
            ]
        };

        // ==========================================
        // SCENE
        // ==========================================
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
        camera.position.set(0, 40, 260);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // OrbitControls Fix check
        let controls;
        if(THREE.OrbitControls) {
            controls = new THREE.OrbitControls(camera, renderer.domElement);
        } else {
            // Fallback manually just in case
            console.warn("OrbitControls manual check");
            if(window.THREE && window.THREE.OrbitControls) {
                 controls = new THREE.OrbitControls(camera, renderer.domElement);
            }
        }
        if(controls) {
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;
        }

        // Glow Texture Generator
        function createGlowTexture() {
            const c = document.createElement('canvas'); c.width=64; c.height=64;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(32,32,0, 32,32,32);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(0.4, 'rgba(255,255,255,0.2)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g; ctx.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(c);
        }
        const glowTex = createGlowTexture();
        const interactables = [];
        const allNodes = []; // For connections

        const mainGroup = new THREE.Group();
        scene.add(mainGroup);

        // ==========================================
        // OBJECTS
        // ==========================================

        // A. OS CORE
        const osGroup = new THREE.Group();
        mainGroup.add(osGroup);
        // Wireframe Brain
        const coreGeo = new THREE.IcosahedronGeometry(15, 1);
        const coreMat = new THREE.MeshBasicMaterial({ color: 0x0088ff, wireframe: true, transparent: true, opacity: 0.15 });
        const core = new THREE.Mesh(coreGeo, coreMat);
        osGroup.add(core);

        DATA.OS.forEach((d, i) => {
            const phi = Math.acos( -1 + ( 2 * i ) / 8 );
            const theta = Math.sqrt( 8 * Math.PI ) * phi;
            const r = 20;
            const x = r * Math.cos(theta) * Math.sin(phi);
            const y = r * Math.sin(theta) * Math.sin(phi);
            const z = r * Math.cos(phi);
            const pos = new THREE.Vector3(x, y, z);

            const mesh = new THREE.Mesh(new THREE.SphereGeometry(2), new THREE.MeshBasicMaterial({ color: d.color }));
            mesh.position.copy(pos);
            mesh.userData = { type: 'OS', data: d };
            
            // Glow Sprite
            const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: glowTex, color: d.color, blending: THREE.AdditiveBlending }));
            spr.scale.set(25,25,1);
            mesh.add(spr);

            osGroup.add(mesh);
            interactables.push(mesh);
            allNodes.push({ pos: pos, color: new THREE.Color(d.color), group:'OS' });
        });

        // B. COEFFICIENTS
        const coefGroup = new THREE.Group();
        mainGroup.add(coefGroup);
        const coefMeshes = [];

        DATA.COEF.forEach((d, i) => {
            const angle = (i / 8) * Math.PI * 2;
            const rad = 70;
            const x = Math.cos(angle) * rad;
            const z = Math.sin(angle) * rad;
            const pos = new THREE.Vector3(x, 0, z);

            const mesh = new THREE.Mesh(new THREE.BoxGeometry(4,4,4), new THREE.MeshBasicMaterial({ color: d.color, wireframe: true }));
            mesh.position.copy(pos);
            mesh.userData = { type: 'COEF', data: d };

            const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: glowTex, color: d.color, blending: THREE.AdditiveBlending }));
            spr.scale.set(35,35,1);
            mesh.add(spr);

            coefGroup.add(mesh);
            interactables.push(mesh);
            coefMeshes.push(mesh);
            allNodes.push({ pos: pos, color: new THREE.Color(d.color), group:'COEF' });
        });

        // C. DB CLOUDS
        const dbGroup = new THREE.Group();
        mainGroup.add(dbGroup);

        DATA.DB.forEach(d => {
            const count = 100;
            const geo = new THREE.Geometry(); 
            for(let i=0; i<count; i++) {
                const spread = 40;
                const v = new THREE.Vector3(
                    d.pos[0] + (Math.random()-0.5)*spread,
                    d.pos[1] + (Math.random()-0.5)*spread,
                    d.pos[2] + (Math.random()-0.5)*spread
                );
                geo.vertices.push(v);
                if(Math.random()>0.92) allNodes.push({ pos: v, color: new THREE.Color(d.color), group:'DB' });
            }
            const mat = new THREE.PointsMaterial({ color: d.color, size: 2, map: glowTex, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending, depthWrite: false });
            const pts = new THREE.Points(geo, mat);
            dbGroup.add(pts);

            const box = new THREE.Mesh(new THREE.BoxGeometry(50,50,50), new THREE.MeshBasicMaterial({visible:false}));
            box.position.set(d.pos[0], d.pos[1], d.pos[2]);
            box.userData = { type: 'DB', data: d };
            interactables.push(box);
        });

        // D. NEURAL CONNECTIONS (KamuiOS Style)
        const lineGeo = new THREE.Geometry();
        const lineColors = [];
        
        for(let i=0; i<allNodes.length; i++) {
            for(let j=i+1; j<allNodes.length; j++) {
                const n1 = allNodes[i];
                const n2 = allNodes[j];
                const dist = n1.pos.distanceTo(n2.pos);
                // 距離が近く、かつ異なるグループ間などを繋ぐ
                if(dist < 90 && (dist < 25 || n1.group !== n2.group)) {
                    lineGeo.vertices.push(n1.pos);
                    lineGeo.vertices.push(n2.pos);
                    lineColors.push(n1.color);
                    lineColors.push(n2.color);
                }
            }
        }
        lineGeo.colors = lineColors;
        const lineMat = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors, transparent: true, opacity: 0.1, blending: THREE.AdditiveBlending });
        const synapses = new THREE.LineSegments(lineGeo, lineMat);
        mainGroup.add(synapses);

        // E. LOGIC PULSE
        const pulse = new THREE.Mesh(new THREE.SphereGeometry(2), new THREE.MeshBasicMaterial({color:0xffffff}));
        const pulseSpr = new THREE.Sprite(new THREE.SpriteMaterial({map: glowTex, color: 0xffffff, blending: THREE.AdditiveBlending}));
        pulseSpr.scale.set(20,20,1);
        pulse.add(pulseSpr);
        scene.add(pulse);

        // ==========================================
        // ANIMATION
        // ==========================================
        const clock = new THREE.Clock();
        const flowText = document.getElementById('logic-flow');
        
        // Remove Loader
        setTimeout(function(){
            document.getElementById('loader').style.opacity = 0;
            setTimeout(function(){ document.getElementById('loader').style.display='none'; }, 500);
        }, 1000);

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            if(controls) controls.update();

            // Orgnaic Motion
            osGroup.rotation.y = Math.sin(time*0.2)*0.2;
            osGroup.scale.setScalar(1 + Math.sin(time*3)*0.02); // Heartbeat
            
            coefGroup.rotation.y = time * -0.15;
            coefMeshes.forEach((m,i) => {
                m.rotation.x += 0.02; 
                m.position.y = Math.sin(time + i)*5;
            });
            synapses.rotation.y = Math.sin(time*0.1)*0.05;

            // Loop Logic
            const t = time % 6.0;
            let target = new THREE.Vector3();
            let col = 0xffffff;
            let txt = "";

            if (t < 1.5) {
                let p = t/1.5;
                target.set(0, 160*(1-p), 120*(1-p));
                txt = ">>> INPUT SIGNAL >>>";
            } else if (t < 3.5) {
                let p = (t-1.5)/2.0;
                let db = new THREE.Vector3(90, 60, -60);
                if(p<0.5) target.lerpVectors(new THREE.Vector3(), db, p*2);
                else target.lerpVectors(db, new THREE.Vector3(), (p-0.5)*2);
                col = 0x0055FF;
                txt = "::: NEURAL MEMORY ACCESS :::";
            } else if (t < 4.5) {
                let p = (t-3.5);
                target.lerpVectors(new THREE.Vector3(), new THREE.Vector3(70,0,0), p);
                col = 0x00CCFF;
                txt = "/// PROCESSING VECTOR ///";
            } else {
                let p = (t-4.5)/1.5;
                target.lerpVectors(new THREE.Vector3(70,0,0), new THREE.Vector3(250,0,0), p);
                col = 0xFF3300;
                txt = "!!! ACTION OUTPUT !!!";
            }

            pulse.position.copy(target);
            pulse.material.color.setHex(col);
            pulseSpr.material.color.setHex(col);
            flowText.innerText = txt;
            flowText.style.color = '#' + col.toString(16).padStart(6,'0');

            renderer.render(scene, camera);
        }
        animate();

        // Interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        window.addEventListener('mousedown', function(e){
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(interactables);
            if(hits.length > 0) {
                showPanel(hits[0].object.userData);
            }
        });

        function showPanel(ud) {
            const p = document.getElementById('panel');
            document.getElementById('p-title').innerText = ud.data.name || ud.data.id;
            document.getElementById('p-desc').innerText = ud.data.desc;
            document.getElementById('p-type').innerText = ud.type;
            p.classList.add('active');
        }

        window.addEventListener('resize', function(){
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
